"object" == typeof navigator && function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("Plyr", t) : (e = "undefined" == typeof globalThis ? e || self : globalThis, e.Plyr = t())
}(this, function() {
    'use strict';

    function e(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function a(n, e) {
        if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function i(a, e) {
        for (var t, i = 0; i < e.length; i++) t = e[i], t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(a, t.key, t)
    }

    function l(a, e, t) {
        return e && i(a.prototype, e), t && i(a, t), a
    }

    function o(a, e, t) {
        return e in a ? Object.defineProperty(a, e, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : a[e] = t, a
    }

    function s(a, e) {
        var t = Object.keys(a);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(a);
            e && (n = n.filter(function(e) {
                return Object.getOwnPropertyDescriptor(a, e).enumerable
            })), t.push.apply(t, n)
        }
        return t
    }

    function d(a) {
        for (var e, i = 1; i < arguments.length; i++) e = null == arguments[i] ? {} : arguments[i], i % 2 ? s(Object(e), !0).forEach(function(n) {
            o(a, n, e[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(e)) : s(Object(e)).forEach(function(n) {
            Object.defineProperty(a, n, Object.getOwnPropertyDescriptor(e, n))
        });
        return a
    }

    function c(n, e) {
        return function() {
            return Array.from(document.querySelectorAll(e)).includes(this)
        }.call(n, e)
    }

    function u(a, e) {
        if (a && e) {
            var t = new Event(e, {
                bubbles: !0
            });
            a.dispatchEvent(t)
        }
    }

    function m(n) {
        var e = "".concat(n).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
        return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0
    }

    function p(a, e) {
        if (1 > e) {
            var t = m(e);
            return parseFloat(a.toFixed(t))
        }
        return Math.round(a / e) * e
    }

    function g(e, t) {
        setTimeout(() => {
            try {
                e.hidden = !0, e.offsetHeight, e.hidden = !1
            } catch (e) {}
        }, t)
    }

    function f(e, t) {
        return t.split(".").reduce((e, t) => e && e[t], e)
    }

    function y(e = {}, ...t) {
        if (!t.length) return e;
        const n = t.shift();
        return qe.object(n) ? (Object.keys(n).forEach(t => {
            qe.object(n[t]) ? (!Object.keys(e).includes(t) && Object.assign(e, {
                [t]: {}
            }), y(e[t], n[t])) : Object.assign(e, {
                [t]: n[t]
            })
        }), y(e, ...t)) : e
    }

    function b(e, t) {
        const n = e.length ? e : [e];
        Array.from(n).reverse().forEach((e, n) => {
            const a = 0 < n ? t.cloneNode(!0) : t,
                i = e.parentNode,
                l = e.nextSibling;
            a.appendChild(e), l ? i.insertBefore(a, l) : i.appendChild(a)
        })
    }

    function h(e, t) {
        !qe.element(e) || qe.empty(t) || Object.entries(t).filter(([, e]) => !qe.nullOrUndefined(e)).forEach(([t, n]) => e.setAttribute(t, n))
    }

    function v(e, t, n) {
        const a = document.createElement(e);
        return qe.object(t) && h(a, t), qe.string(n) && (a.innerText = n), a
    }

    function k(e, t) {
        qe.element(e) && qe.element(t) && t.parentNode.insertBefore(e, t.nextSibling)
    }

    function T(e, t, n, a) {
        qe.element(t) && t.appendChild(v(e, n, a))
    }

    function w(e) {
        return qe.nodeList(e) || qe.array(e) ? void Array.from(e).forEach(w) : void(!qe.element(e) || !qe.element(e.parentNode) || e.parentNode.removeChild(e))
    }

    function C(e) {
        if (qe.element(e))
            for (let {
                    length: t
                } = e.childNodes; 0 < t;) e.removeChild(e.lastChild), t -= 1
    }

    function A(e, t) {
        return qe.element(t) && qe.element(t.parentNode) && qe.element(e) ? (t.parentNode.replaceChild(e, t), e) : null
    }

    function E(e, t) {
        if (!qe.string(e) || qe.empty(e)) return {};
        const n = {},
            a = y({}, t);
        return e.split(",").forEach(e => {
            const t = e.trim(),
                i = t.replace(".", ""),
                l = t.replace(/[[\]]/g, ""),
                o = l.split("="),
                [s] = o,
                r = 1 < o.length ? o[1].replace(/["']/g, "") : "",
                d = t.charAt(0);
            "." === d ? n.class = qe.string(a.class) ? `${a.class} ${i}` : i : "#" === d ? n.id = t.replace("#", "") : "[" === d ? n[s] = r : void 0
        }), y(a, n)
    }

    function S(e, t) {
        if (!qe.element(e)) return;
        let n = t;
        qe.boolean(n) || (n = !e.hidden), e.hidden = n
    }

    function P(e, t, n) {
        if (qe.nodeList(e)) return Array.from(e).map(a => P(a, t, n));
        if (qe.element(e)) {
            let a = "toggle";
            return "undefined" != typeof n && (a = n ? "add" : "remove"), e.classList[a](t), e.classList.contains(t)
        }
        return !1
    }

    function x(e, t) {
        return qe.element(e) && e.classList.contains(t)
    }

    function L(e, t) {
        const {
            prototype: n
        } = Element, a = n.matches || n.webkitMatchesSelector || n.mozMatchesSelector || n.msMatchesSelector || function() {
            return Array.from(document.querySelectorAll(t)).includes(this)
        };
        return a.call(e, t)
    }

    function N(e, t) {
        const {
            prototype: n
        } = Element, a = n.closest || function() {
            let e = this;
            do {
                if (L.matches(e, t)) return e;
                e = e.parentElement || e.parentNode
            } while (null !== e && 1 === e.nodeType);
            return null
        };
        return a.call(e, t)
    }

    function M(e) {
        return this.elements.container.querySelectorAll(e)
    }

    function I(e) {
        return this.elements.container.querySelector(e)
    }

    function _(e = null, t = !1) {
        qe.element(e) && (e.focus({
            preventScroll: !0
        }), t && P(e, this.config.classNames.tabFocus))
    }

    function H(e, t, n, a = !1, i = !0, l = !1) {
        if (!e || !("addEventListener" in e) || qe.empty(t) || !qe.function(n)) return;
        const o = t.split(" ");
        let s = l;
        Ue && (s = {
            passive: i,
            capture: l
        }), o.forEach(t => {
            this && this.eventListeners && a && this.eventListeners.push({
                element: e,
                type: t,
                callback: n,
                options: s
            }), e[a ? "addEventListener" : "removeEventListener"](t, n, s)
        })
    }

    function q(e, t = "", n, a = !0, i = !1) {
        H.call(this, e, t, n, !0, a, i)
    }

    function t(e, t = "", n, a = !0, i = !1) {
        H.call(this, e, t, n, !1, a, i)
    }

    function n(e, n = "", a, i = !0, l = !1) {
        const o = (...s) => {
            t(e, n, o, i, l), a.apply(this, s)
        };
        H.call(this, e, n, o, !0, i, l)
    }

    function r(e, t = "", n = !1, a = {}) {
        if (qe.element(e) && !qe.empty(t)) {
            const i = new CustomEvent(t, {
                bubbles: n,
                detail: { ...a,
                    plyr: this
                }
            });
            e.dispatchEvent(i)
        }
    }

    function D() {
        this && this.eventListeners && (this.eventListeners.forEach(e => {
            const {
                element: t,
                type: n,
                callback: a,
                options: i
            } = e;
            t.removeEventListener(n, a, i)
        }), this.eventListeners = [])
    }

    function F() {
        return new Promise(e => this.ready ? setTimeout(e, 0) : q.call(this, this.elements.container, "ready", e)).then(() => {})
    }

    function R(e) {
        qe.promise(e) && e.then(null, () => {})
    }

    function V(e) {
        return qe.array(e) ? e.filter((t, n) => e.indexOf(t) === n) : e
    }

    function U(e, t) {
        return qe.array(e) && e.length ? e.reduce((e, n) => Math.abs(n - t) < Math.abs(e - t) ? n : e) : null
    }

    function W(e) {
        return !!(window && window.CSS) && window.CSS.supports(e)
    }

    function O(e) {
        if (!qe.array(e) && (!qe.string(e) || !e.includes(":"))) return !1;
        const t = qe.array(e) ? e : e.split(":");
        return t.map(Number).every(qe.number)
    }

    function z(e) {
        if (!qe.array(e) || !e.every(qe.number)) return null;
        const [t, n] = e, a = (e, t) => 0 === t ? e : a(t, e % t), i = a(t, n);
        return [t / i, n / i]
    }

    function j(e) {
        const t = e => O(e) ? e.split(":").map(Number) : null;
        let n = t(e);
        if (null === n && (n = t(this.config.ratio)), null === n && !qe.empty(this.embed) && qe.array(this.embed.ratio) && ({
                ratio: n
            } = this.embed), null === n && this.isHTML5) {
            const {
                videoWidth: e,
                videoHeight: t
            } = this.media;
            n = [e, t]
        }
        return z(n)
    }

    function B(e) {
        if (!this.isVideo) return {};
        const {
            wrapper: t
        } = this.elements, n = j.call(this, e);
        if (!qe.array(n)) return {};
        const [a, i] = z(n), l = W(`aspect-ratio: ${a}/${i}`), o = 100 / a * i;
        if (l ? t.style.aspectRatio = `${a}/${i}` : t.style.paddingBottom = `${o}%`, this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
            const e = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10);
            this.fullscreen.active ? t.style.paddingBottom = null : this.media.style.transform = `translateY(-${(e-o)/(e/50)}%)`
        } else this.isHTML5 && t.classList.add(this.config.classNames.videoFixedRatio);
        return {
            padding: o,
            ratio: n
        }
    }

    function K(e, t, n = .05) {
        const a = e / t,
            i = U(Object.keys(We), a);
        return Math.abs(i - a) <= n ? We[i] : [e, t]
    }

    function Y() {
        const e = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
            t = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        return [e, t]
    }

    function X(e) {
        return `${e}-${Math.floor(1e4*Math.random())}`
    }

    function Q(e, ...t) {
        return qe.empty(e) ? e : e.toString().replace(/{(\d+)}/g, (e, n) => t[n].toString())
    }

    function G(e, t) {
        return 0 === e || 0 === t || Number.isNaN(e) || Number.isNaN(t) ? 0 : (100 * (e / t)).toFixed(2)
    }

    function $(e = "") {
        let t = e.toString();
        return t = ze(t, "-", " "), t = ze(t, "_", " "), t = je(t), ze(t, " ", "")
    }

    function J(e = "") {
        let t = e.toString();
        return t = $(t), t.charAt(0).toLowerCase() + t.slice(1)
    }

    function Z(e) {
        const t = document.createDocumentFragment(),
            n = document.createElement("div");
        return t.appendChild(n), n.innerHTML = e, t.firstChild.innerText
    }

    function ee(e) {
        const t = document.createElement("div");
        return t.appendChild(e), t.innerHTML
    }

    function te(e, t = "text") {
        return new Promise((n, a) => {
            try {
                const a = new XMLHttpRequest;
                if (!("withCredentials" in a)) return;
                a.addEventListener("load", () => {
                    if ("text" === t) try {
                        n(JSON.parse(a.responseText))
                    } catch (e) {
                        n(a.responseText)
                    } else n(a.response)
                }), a.addEventListener("error", () => {
                    throw new Error(a.status)
                }), a.open("GET", e, !0), a.responseType = t, a.send()
            } catch (e) {
                a(e)
            }
        })
    }

    function ne(e, t) {
        if (!qe.string(e)) return;
        const n = "cache",
            a = qe.string(t);
        let i = !1;
        const l = () => null !== document.getElementById(t),
            o = (e, t) => {
                e.innerHTML = t, a && l() || document.body.insertAdjacentElement("afterbegin", e)
            };
        if (!a || !l()) {
            const l = Ye.supported,
                s = document.createElement("div");
            if (s.setAttribute("hidden", ""), a && s.setAttribute("id", t), l) {
                const e = window.localStorage.getItem(`${n}-${t}`);
                if (i = null !== e, i) {
                    const t = JSON.parse(e);
                    o(s, t.content)
                }
            }
            te(e).then(e => {
                if (!qe.empty(e)) {
                    if (l) try {
                        window.localStorage.setItem(`${n}-${t}`, JSON.stringify({
                            content: e
                        }))
                    } catch (e) {}
                    o(s, e)
                }
            }).catch(() => {})
        }
    }

    function ae(e = 0, t = !1, n = !1) {
        if (!qe.number(e)) return ae(void 0, t, n);
        const a = e => `0${e}`.slice(-2);
        let i = Xe(e);
        const l = Qe(e),
            o = Ge(e);
        return i = t || 0 < i ? `${i}:` : "", `${n&&0<e?"-":""}${i}${a(l)}:${a(o)}`
    }

    function ie(e, t = !0) {
        let n = e;
        if (t) {
            const e = document.createElement("a");
            e.href = n, n = e.href
        }
        try {
            return new URL(n)
        } catch (e) {
            return null
        }
    }

    function le(e) {
        const t = new URLSearchParams;
        return qe.object(e) && Object.entries(e).forEach(([e, n]) => {
            t.set(e, n)
        }), t
    }

    function oe(e) {
        return /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(e) ? tt.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e) ? tt.vimeo : null
    }

    function se(e, t = 1) {
        return new Promise((n, a) => {
            const i = new Image,
                l = () => {
                    delete i.onload, delete i.onerror, (i.naturalWidth >= t ? n : a)(i)
                };
            Object.assign(i, {
                onload: l,
                onerror: l,
                src: e
            })
        })
    }

    function re(e) {
        return new Promise((t, n) => {
            dt(e, {
                success: t,
                error: n
            })
        })
    }

    function de(e) {
        if (qe.empty(e)) return null;
        if (qe.number(+e)) return e;
        return e.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : e
    }

    function ce(e) {
        const t = e.match(/^.*(vimeo.com\/|video\/)(\d+)(\?.*&*h=|\/)+([\d,a-f]+)/);
        return t && 5 === t.length ? t[4] : null
    }

    function ue(e) {
        e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, r.call(this, this.media, e ? "play" : "pause"))
    }

    function me(e) {
        if (qe.empty(e)) return null;
        return e.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : e
    }

    function pe(e) {
        e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, r.call(this, this.media, e ? "play" : "pause"))
    }

    function ge(e) {
        return e.noCookie ? "https://www.youtube-nocookie.com" : "http:" === window.location.protocol ? "http://www.youtube.com" : void 0
    }

    function fe(e = 0, t = 0, n = 255) {
        return Math.min(Math.max(e, t), n)
    }
    var ye = {
            addCSS: !0,
            thumbWidth: 15,
            watch: !0
        },
        be = function(t) {
            return null == t ? null : t.constructor
        },
        he = function(n, e) {
            return !!(n && e && n instanceof e)
        },
        ve = function(t) {
            return null == t
        },
        ke = function(t) {
            return be(t) === Object
        },
        Te = function(t) {
            return be(t) === String
        },
        we = function(t) {
            return Array.isArray(t)
        },
        Ce = function(t) {
            return he(t, NodeList)
        },
        Ae = {
            nullOrUndefined: ve,
            object: ke,
            number: function(t) {
                return be(t) === Number && !Number.isNaN(t)
            },
            string: Te,
            boolean: function(t) {
                return be(t) === Boolean
            },
            function: function(t) {
                return be(t) === Function
            },
            array: we,
            nodeList: Ce,
            element: function(t) {
                return he(t, Element)
            },
            event: function(t) {
                return he(t, Event)
            },
            empty: function(t) {
                return ve(t) || (Te(t) || we(t) || Ce(t)) && !t.length || ke(t) && !Object.keys(t).length
            }
        },
        Ee = function() {
            function m(e, t) {
                a(this, m), Ae.element(e) ? this.element = e : Ae.string(e) && (this.element = document.querySelector(e)), Ae.element(this.element) && Ae.empty(this.element.rangeTouch) && (this.config = d({}, ye, {}, t), this.init())
            }
            return l(m, [{
                key: "init",
                value: function() {
                    m.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this)
                }
            }, {
                key: "destroy",
                value: function() {
                    m.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null)
                }
            }, {
                key: "listeners",
                value: function(a) {
                    var i = this,
                        t = a ? "addEventListener" : "removeEventListener";
                    ["touchstart", "touchmove", "touchend"].forEach(function(n) {
                        i.element[t](n, function(t) {
                            return i.set(t)
                        }, !1)
                    })
                }
            }, {
                key: "get",
                value: function(e) {
                    if (!m.enabled || !Ae.event(e)) return null;
                    var t, l = e.target,
                        r = e.changedTouches[0],
                        i = parseFloat(l.getAttribute("min")) || 0,
                        o = parseFloat(l.getAttribute("max")) || 100,
                        s = parseFloat(l.getAttribute("step")) || 1,
                        d = l.getBoundingClientRect(),
                        c = 100 / d.width * (this.config.thumbWidth / 2) / 100;
                    return 0 > (t = 100 / d.width * (r.clientX - d.left)) ? t = 0 : 100 < t && (t = 100), 50 > t ? t -= (100 - 2 * t) * c : 50 < t && (t += 2 * (t - 50) * c), i + p(t / 100 * (o - i), s)
                }
            }, {
                key: "set",
                value: function(e) {
                    m.enabled && Ae.event(e) && !e.target.disabled && (e.preventDefault(), e.target.value = this.get(e), u(e.target, "touchend" === e.type ? "change" : "input"))
                }
            }], [{
                key: "setup",
                value: function(e) {
                    var a = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                        t = null;
                    if (Ae.empty(e) || Ae.string(e) ? t = Array.from(document.querySelectorAll(Ae.string(e) ? e : "input[type=\"range\"]")) : Ae.element(e) ? t = [e] : Ae.nodeList(e) ? t = Array.from(e) : Ae.array(e) && (t = e.filter(Ae.element)), Ae.empty(t)) return null;
                    var l = d({}, ye, {}, a);
                    if (Ae.string(e) && l.watch) {
                        var n = new MutationObserver(function(t) {
                            Array.from(t).forEach(function(t) {
                                Array.from(t.addedNodes).forEach(function(t) {
                                    Ae.element(t) && c(t, e) && new m(t, l)
                                })
                            })
                        });
                        n.observe(document.body, {
                            childList: !0,
                            subtree: !0
                        })
                    }
                    return t.map(function(e) {
                        return new m(e, a)
                    })
                }
            }, {
                key: "enabled",
                get: function() {
                    return "ontouchstart" in document.documentElement
                }
            }]), m
        }();
    const Se = e => null !== e && "undefined" != typeof e ? e.constructor : null,
        Pe = (e, t) => !!(e && t && e instanceof t),
        xe = e => null === e || "undefined" == typeof e,
        Le = e => Se(e) === Object,
        Ne = e => Se(e) === String,
        Me = e => "function" == typeof e,
        Ie = e => Array.isArray(e),
        _e = e => Pe(e, NodeList),
        He = e => xe(e) || (Ne(e) || Ie(e) || _e(e)) && !e.length || Le(e) && !Object.keys(e).length;
    var qe = {
        nullOrUndefined: xe,
        object: Le,
        number: e => Se(e) === Number && !Number.isNaN(e),
        string: Ne,
        boolean: e => Se(e) === Boolean,
        function: Me,
        array: Ie,
        weakMap: e => Pe(e, WeakMap),
        nodeList: _e,
        element: e => null !== e && "object" == typeof e && 1 === e.nodeType && "object" == typeof e.style && "object" == typeof e.ownerDocument,
        textNode: e => Se(e) === Text,
        event: e => Pe(e, Event),
        keyboardEvent: e => Pe(e, KeyboardEvent),
        cue: e => Pe(e, window.TextTrackCue) || Pe(e, window.VTTCue),
        track: e => Pe(e, TextTrack) || !xe(e) && Ne(e.kind),
        promise: e => Pe(e, Promise) && Me(e.then),
        url: e => {
            if (Pe(e, window.URL)) return !0;
            if (!Ne(e)) return !1;
            let t = e;
            e.startsWith("http://") && e.startsWith("https://") || (t = `http://${e}`);
            try {
                return !He(new URL(t).hostname)
            } catch (e) {
                return !1
            }
        },
        empty: He
    };
    const De = (() => {
            const e = document.createElement("span"),
                t = {
                    WebkitTransition: "webkitTransitionEnd",
                    MozTransition: "transitionend",
                    OTransition: "oTransitionEnd otransitionend",
                    transition: "transitionend"
                },
                n = Object.keys(t).find(t => void 0 !== e.style[t]);
            return !!qe.string(n) && t[n]
        })(),
        Fe = {
            isIE: !!window.document.documentMode,
            isEdge: /Edge/g.test(navigator.userAgent),
            isWebkit: "WebkitAppearance" in document.documentElement.style && !/Edge/g.test(navigator.userAgent),
            isIPhone: /iPhone|iPod/gi.test(navigator.userAgent) && 1 < navigator.maxTouchPoints,
            isIos: /iPad|iPhone|iPod/gi.test(navigator.userAgent) && 1 < navigator.maxTouchPoints
        },
        Re = {
            "audio/ogg": "vorbis",
            "audio/wav": "1",
            "video/webm": "vp8, vorbis",
            "video/mp4": "avc1.42E01E, mp4a.40.2",
            "video/ogg": "theora"
        },
        Ve = {
            audio: "canPlayType" in document.createElement("audio"),
            video: "canPlayType" in document.createElement("video"),
            check(e, t, n) {
                const a = Fe.isIPhone && n && Ve.playsinline,
                    i = Ve[e] || "html5" !== t,
                    l = i && Ve.rangeInput && ("video" !== e || !Fe.isIPhone || a);
                return {
                    api: i,
                    ui: l
                }
            },
            pip: (() => !Fe.isIPhone && (!!qe.function(v("video").webkitSetPresentationMode) || document.pictureInPictureEnabled && !v("video").disablePictureInPicture))(),
            airplay: qe.function(window.WebKitPlaybackTargetAvailabilityEvent),
            playsinline: "playsInline" in document.createElement("video"),
            mime(e) {
                if (qe.empty(e)) return !1;
                const [t] = e.split("/");
                let n = e;
                if (!this.isHTML5 || t !== this.type) return !1;
                Object.keys(Re).includes(n) && (n += `; codecs="${Re[e]}"`);
                try {
                    return !!(n && this.media.canPlayType(n).replace(/no/, ""))
                } catch (e) {
                    return !1
                }
            },
            textTracks: "textTracks" in document.createElement("video"),
            rangeInput: (() => {
                const e = document.createElement("input");
                return e.type = "range", "range" === e.type
            })(),
            touch: "ontouchstart" in document.documentElement,
            transitions: !1 !== De,
            reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches
        },
        Ue = (() => {
            let e = !1;
            try {
                const t = Object.defineProperty({}, "passive", {
                    get() {
                        return e = !0, null
                    }
                });
                window.addEventListener("test", null, t), window.removeEventListener("test", null, t)
            } catch (e) {}
            return e
        })(),
        We = [
            [1, 1],
            [4, 3],
            [3, 4],
            [5, 4],
            [4, 5],
            [3, 2],
            [2, 3],
            [16, 10],
            [10, 16],
            [16, 9],
            [9, 16],
            [21, 9],
            [9, 21],
            [32, 9],
            [9, 32]
        ].reduce((e, [t, n]) => ({ ...e,
            [t / n]: [t, n]
        }), {}),
        Oe = {
            getSources() {
                if (!this.isHTML5) return [];
                const e = Array.from(this.media.querySelectorAll("source"));
                return e.filter(e => {
                    const t = e.getAttribute("type");
                    return !!qe.empty(t) || Ve.mime.call(this, t)
                })
            },
            getQualityOptions() {
                return this.config.quality.forced ? this.config.quality.options : Oe.getSources.call(this).map(e => +e.getAttribute("size")).filter(Boolean)
            },
            setup() {
                if (!this.isHTML5) return;
                const e = this;
                e.options.speed = e.config.speed.options, qe.empty(this.config.ratio) || B.call(e), Object.defineProperty(e.media, "quality", {
                    get() {
                        const t = Oe.getSources.call(e),
                            n = t.find(t => t.getAttribute("src") === e.source);
                        return n && +n.getAttribute("size")
                    },
                    set(t) {
                        if (e.quality !== t) {
                            if (e.config.quality.forced && qe.function(e.config.quality.onChange)) e.config.quality.onChange(t);
                            else {
                                const n = Oe.getSources.call(e),
                                    a = n.find(e => +e.getAttribute("size") === t);
                                if (!a) return;
                                const {
                                    currentTime: i,
                                    paused: l,
                                    preload: o,
                                    readyState: s,
                                    playbackRate: r
                                } = e.media;
                                e.media.src = a.getAttribute("src"), ("none" !== o || s) && (e.once("loadedmetadata", () => {
                                    e.speed = r, e.currentTime = i, l || R(e.play())
                                }), e.media.load())
                            }
                            r.call(e, e.media, "qualitychange", !1, {
                                quality: t
                            })
                        }
                    }
                })
            },
            cancelRequests() {
                this.isHTML5 && (w(Oe.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"))
            }
        },
        ze = (e = "", t = "", n = "") => e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), n.toString()),
        je = (e = "") => e.toString().replace(/\w\S*/g, e => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()),
        Be = {
            pip: "PIP",
            airplay: "AirPlay",
            html5: "HTML5",
            vimeo: "Vimeo",
            youtube: "YouTube"
        },
        Ke = {
            get(e = "", t = {}) {
                if (qe.empty(e) || qe.empty(t)) return "";
                let n = f(t.i18n, e);
                if (qe.empty(n)) return Object.keys(Be).includes(e) ? Be[e] : "";
                const a = {
                    "{seektime}": t.seekTime,
                    "{title}": t.title
                };
                return Object.entries(a).forEach(([e, t]) => {
                    n = ze(n, e, t)
                }), n
            }
        };
    class Ye {
        constructor(t) {
            e(this, "get", e => {
                if (!Ye.supported || !this.enabled) return null;
                const t = window.localStorage.getItem(this.key);
                if (qe.empty(t)) return null;
                const n = JSON.parse(t);
                return qe.string(e) && e.length ? n[e] : n
            }), e(this, "set", e => {
                if (!Ye.supported || !this.enabled) return;
                if (!qe.object(e)) return;
                let t = this.get();
                qe.empty(t) && (t = {}), y(t, e);
                try {
                    window.localStorage.setItem(this.key, JSON.stringify(t))
                } catch (e) {}
            }), this.enabled = t.config.storage.enabled, this.key = t.config.storage.key
        }
        static get supported() {
            try {
                if (!("localStorage" in window)) return !1;
                return window.localStorage.setItem("___test", "___test"), window.localStorage.removeItem("___test"), !0
            } catch (e) {
                return !1
            }
        }
    }
    const Xe = e => Math.trunc(e / 60 / 60 % 60, 10),
        Qe = e => Math.trunc(e / 60 % 60, 10),
        Ge = e => Math.trunc(e % 60, 10),
        $e = {
            getIconUrl() {
                const e = new URL(this.config.iconUrl, window.location),
                    t = window.location.host ? window.location.host : window.top.location.host,
                    n = e.host !== t || Fe.isIE && !window.svg4everybody;
                return {
                    url: this.config.iconUrl,
                    cors: n
                }
            },
            findElements() {
                try {
                    return this.elements.controls = I.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {
                        play: M.call(this, this.config.selectors.buttons.play),
                        pause: I.call(this, this.config.selectors.buttons.pause),
                        restart: I.call(this, this.config.selectors.buttons.restart),
                        rewind: I.call(this, this.config.selectors.buttons.rewind),
                        fastForward: I.call(this, this.config.selectors.buttons.fastForward),
                        mute: I.call(this, this.config.selectors.buttons.mute),
                        pip: I.call(this, this.config.selectors.buttons.pip),
                        airplay: I.call(this, this.config.selectors.buttons.airplay),
                        settings: I.call(this, this.config.selectors.buttons.settings),
                        captions: I.call(this, this.config.selectors.buttons.captions),
                        fullscreen: I.call(this, this.config.selectors.buttons.fullscreen)
                    }, this.elements.progress = I.call(this, this.config.selectors.progress), this.elements.inputs = {
                        seek: I.call(this, this.config.selectors.inputs.seek),
                        volume: I.call(this, this.config.selectors.inputs.volume)
                    }, this.elements.display = {
                        buffer: I.call(this, this.config.selectors.display.buffer),
                        currentTime: I.call(this, this.config.selectors.display.currentTime),
                        duration: I.call(this, this.config.selectors.display.duration)
                    }, qe.element(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`)), !0
                } catch (e) {
                    return this.debug.warn("It looks like there is a problem with your custom controls HTML", e), this.toggleNativeControls(!0), !1
                }
            },
            createIcon(e, t) {
                const n = $e.getIconUrl.call(this),
                    a = `${n.cors?"":n.url}#${this.config.iconPrefix}`,
                    i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                h(i, y(t, {
                    "aria-hidden": "true",
                    focusable: "false"
                }));
                const l = document.createElementNS("http://www.w3.org/2000/svg", "use"),
                    o = `${a}-${e}`;
                return "href" in l && l.setAttributeNS("http://www.w3.org/1999/xlink", "href", o), l.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o), i.appendChild(l), i
            },
            createLabel(e, t = {}) {
                const n = Ke.get(e, this.config),
                    a = { ...t,
                        class: [t.class, this.config.classNames.hidden].filter(Boolean).join(" ")
                    };
                return v("span", a, n)
            },
            createBadge(e) {
                if (qe.empty(e)) return null;
                const t = v("span", {
                    class: this.config.classNames.menu.value
                });
                return t.appendChild(v("span", {
                    class: this.config.classNames.menu.badge
                }, e)), t
            },
            createButton(e, t) {
                const n = y({}, t);
                let a = J(e);
                const i = {
                    element: "button",
                    toggle: !1,
                    label: null,
                    icon: null,
                    labelPressed: null,
                    iconPressed: null
                };
                ["element", "icon", "label"].forEach(e => {
                    Object.keys(n).includes(e) && (i[e] = n[e], delete n[e])
                }), "button" !== i.element || Object.keys(n).includes("type") || (n.type = "button"), Object.keys(n).includes("class") ? !n.class.split(" ").some(e => e === this.config.classNames.control) && y(n, {
                    class: `${n.class} ${this.config.classNames.control}`
                }) : n.class = this.config.classNames.control, "play" === e ? (i.toggle = !0, i.label = "play", i.labelPressed = "pause", i.icon = "play", i.iconPressed = "pause") : "mute" === e ? (i.toggle = !0, i.label = "mute", i.labelPressed = "unmute", i.icon = "volume", i.iconPressed = "muted") : "captions" === e ? (i.toggle = !0, i.label = "enableCaptions", i.labelPressed = "disableCaptions", i.icon = "captions-off", i.iconPressed = "captions-on") : "fullscreen" === e ? (i.toggle = !0, i.label = "enterFullscreen", i.labelPressed = "exitFullscreen", i.icon = "enter-fullscreen", i.iconPressed = "exit-fullscreen") : "play-large" === e ? (n.class += ` ${this.config.classNames.control}--overlaid`, a = "play", i.label = "play", i.icon = "play") : (qe.empty(i.label) && (i.label = a), qe.empty(i.icon) && (i.icon = e));
                const l = v(i.element);
                return i.toggle ? (l.appendChild($e.createIcon.call(this, i.iconPressed, {
                    class: "icon--pressed"
                })), l.appendChild($e.createIcon.call(this, i.icon, {
                    class: "icon--not-pressed"
                })), l.appendChild($e.createLabel.call(this, i.labelPressed, {
                    class: "label--pressed"
                })), l.appendChild($e.createLabel.call(this, i.label, {
                    class: "label--not-pressed"
                }))) : (l.appendChild($e.createIcon.call(this, i.icon)), l.appendChild($e.createLabel.call(this, i.label))), y(n, E(this.config.selectors.buttons[a], n)), h(l, n), "play" === a ? (!qe.array(this.elements.buttons[a]) && (this.elements.buttons[a] = []), this.elements.buttons[a].push(l)) : this.elements.buttons[a] = l, l
            },
            createRange(e, t) {
                const n = v("input", y(E(this.config.selectors.inputs[e]), {
                    type: "range",
                    min: 0,
                    max: 100,
                    step: .01,
                    value: 0,
                    autocomplete: "off",
                    role: "slider",
                    "aria-label": Ke.get(e, this.config),
                    "aria-valuemin": 0,
                    "aria-valuemax": 100,
                    "aria-valuenow": 0
                }, t));
                return this.elements.inputs[e] = n, $e.updateRangeFill.call(this, n), Ee.setup(n), n
            },
            createProgress(e, t) {
                const n = v("progress", y(E(this.config.selectors.display[e]), {
                    min: 0,
                    max: 100,
                    value: 0,
                    role: "progressbar",
                    "aria-hidden": !0
                }, t));
                if ("volume" !== e) {
                    n.appendChild(v("span", null, "0"));
                    const t = {
                            played: "played",
                            buffer: "buffered"
                        }[e],
                        a = t ? Ke.get(t, this.config) : "";
                    n.innerText = `% ${a.toLowerCase()}`
                }
                return this.elements.display[e] = n, n
            },
            createTime(e, t) {
                const n = E(this.config.selectors.display[e], t),
                    a = v("div", y(n, {
                        class: `${n.class?n.class:""} ${this.config.classNames.display.time} `.trim(),
                        "aria-label": Ke.get(e, this.config)
                    }), "00:00");
                return this.elements.display[e] = a, a
            },
            bindMenuItemShortcuts(e, t) {
                q.call(this, e, "keydown keyup", n => {
                    if ([" ", "ArrowUp", "ArrowDown", "ArrowRight"].includes(n.key) && (n.preventDefault(), n.stopPropagation(), "keydown" !== n.type)) {
                        const a = L(e, "[role=\"menuitemradio\"]");
                        if (!a && [" ", "ArrowRight"].includes(n.key)) $e.showMenuPanel.call(this, t, !0);
                        else {
                            let t;
                            " " !== n.key && ("ArrowDown" === n.key || a && "ArrowRight" === n.key ? (t = e.nextElementSibling, !qe.element(t) && (t = e.parentNode.firstElementChild)) : (t = e.previousElementSibling, !qe.element(t) && (t = e.parentNode.lastElementChild)), _.call(this, t, !0))
                        }
                    }
                }, !1), q.call(this, e, "keyup", e => {
                    "Return" !== e.key || $e.focusFirstMenuItem.call(this, null, !0)
                })
            },
            createMenuItem({
                value: e,
                list: t,
                type: n,
                title: a,
                badge: i = null,
                checked: l = !1
            }) {
                const o = E(this.config.selectors.inputs[n]),
                    s = v("button", y(o, {
                        type: "button",
                        role: "menuitemradio",
                        class: `${this.config.classNames.control} ${o.class?o.class:""}`.trim(),
                        "aria-checked": l,
                        value: e
                    })),
                    r = v("span");
                r.innerHTML = a, qe.element(i) && r.appendChild(i), s.appendChild(r), Object.defineProperty(s, "checked", {
                    enumerable: !0,
                    get() {
                        return "true" === s.getAttribute("aria-checked")
                    },
                    set(e) {
                        e && Array.from(s.parentNode.children).filter(e => L(e, "[role=\"menuitemradio\"]")).forEach(e => e.setAttribute("aria-checked", "false")), s.setAttribute("aria-checked", e ? "true" : "false")
                    }
                }), this.listeners.bind(s, "click keyup", t => {
                    qe.keyboardEvent(t) && " " !== t.key || (t.preventDefault(), t.stopPropagation(), s.checked = !0, "language" === n ? this.currentTrack = +e : "quality" === n ? this.quality = e : "speed" === n ? this.speed = parseFloat(e) : void 0, $e.showMenuPanel.call(this, "home", qe.keyboardEvent(t)))
                }, n, !1), $e.bindMenuItemShortcuts.call(this, s, n), t.appendChild(s)
            },
            formatTime(e = 0, t = !1) {
                if (!qe.number(e)) return e;
                const n = 0 < Xe(this.duration);
                return ae(e, n, t)
            },
            updateTimeDisplay(e = null, t = 0, n = !1) {
                qe.element(e) && qe.number(t) && (e.innerText = $e.formatTime(t, n))
            },
            updateVolume() {
                this.supported.ui && (qe.element(this.elements.inputs.volume) && $e.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), qe.element(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume))
            },
            setRange(e, t = 0) {
                qe.element(e) && (e.value = t, $e.updateRangeFill.call(this, e))
            },
            updateProgress(e) {
                if (!this.supported.ui || !qe.event(e)) return;
                let t = 0;
                const n = (e, t) => {
                    const n = qe.number(t) ? t : 0,
                        a = qe.element(e) ? e : this.elements.display.buffer;
                    if (qe.element(a)) {
                        a.value = n;
                        const e = a.getElementsByTagName("span")[0];
                        qe.element(e) && (e.childNodes[0].nodeValue = n)
                    }
                };
                if (e) switch (e.type) {
                    case "timeupdate":
                    case "seeking":
                    case "seeked":
                        t = G(this.currentTime, this.duration), "timeupdate" === e.type && $e.setRange.call(this, this.elements.inputs.seek, t);
                        break;
                    case "playing":
                    case "progress":
                        n(this.elements.display.buffer, 100 * this.buffered);
                }
            },
            updateRangeFill(e) {
                const t = qe.event(e) ? e.target : e;
                if (qe.element(t) && "range" === t.getAttribute("type")) {
                    if (L(t, this.config.selectors.inputs.seek)) {
                        t.setAttribute("aria-valuenow", this.currentTime);
                        const e = $e.formatTime(this.currentTime),
                            n = $e.formatTime(this.duration),
                            a = Ke.get("seekLabel", this.config);
                        t.setAttribute("aria-valuetext", a.replace("{currentTime}", e).replace("{duration}", n))
                    } else if (L(t, this.config.selectors.inputs.volume)) {
                        const e = 100 * t.value;
                        t.setAttribute("aria-valuenow", e), t.setAttribute("aria-valuetext", `${e.toFixed(1)}%`)
                    } else t.setAttribute("aria-valuenow", t.value);
                    Fe.isWebkit && t.style.setProperty("--value", `${100*(t.value/t.max)}%`)
                }
            },
            updateSeekTooltip(e) {
                var t, n;
                if (!this.config.tooltips.seek || !qe.element(this.elements.inputs.seek) || !qe.element(this.elements.display.seekTooltip) || 0 === this.duration) return;
                const a = this.elements.display.seekTooltip,
                    i = `${this.config.classNames.tooltip}--visible`,
                    l = e => P(a, i, e);
                if (this.touch) return void l(!1);
                let o = 0;
                const s = this.elements.progress.getBoundingClientRect();
                if (qe.event(e)) o = 100 / s.width * (e.pageX - s.left);
                else if (x(a, i)) o = parseFloat(a.style.left, 10);
                else return;
                0 > o ? o = 0 : 100 < o && (o = 100);
                const r = this.duration / 100 * o;
                a.innerText = $e.formatTime(r);
                const d = null === (t = this.config.markers) || void 0 === t || null === (n = t.points) || void 0 === n ? void 0 : n.find(({
                    time: e
                }) => e === Math.round(r));
                d && a.insertAdjacentHTML("afterbegin", `${d.label}<br>`), a.style.left = `${o}%`, qe.event(e) && ["mouseenter", "mouseleave"].includes(e.type) && l("mouseenter" === e.type)
            },
            timeUpdate(e) {
                const t = !qe.element(this.elements.display.duration) && this.config.invertTime;
                $e.updateTimeDisplay.call(this, this.elements.display.currentTime, t ? this.duration - this.currentTime : this.currentTime, t), e && "timeupdate" === e.type && this.media.seeking || $e.updateProgress.call(this, e)
            },
            durationUpdate() {
                if (this.supported.ui && (this.config.invertTime || !this.currentTime)) {
                    if (4294967296 <= this.duration) return S(this.elements.display.currentTime, !0), void S(this.elements.progress, !0);
                    qe.element(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
                    const e = qe.element(this.elements.display.duration);
                    !e && this.config.displayDuration && this.paused && $e.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e && $e.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), this.config.markers.enabled && $e.setMarkers.call(this), $e.updateSeekTooltip.call(this)
                }
            },
            toggleMenuButton(e, t) {
                S(this.elements.settings.buttons[e], !t)
            },
            updateSetting(e, t, n) {
                const a = this.elements.settings.panels[e];
                let i = null,
                    l = t;
                if ("captions" === e) i = this.currentTrack;
                else {
                    if (i = qe.empty(n) ? this[e] : n, qe.empty(i) && (i = this.config[e].default), !qe.empty(this.options[e]) && !this.options[e].includes(i)) return void this.debug.warn(`Unsupported value of '${i}' for ${e}`);
                    if (!this.config[e].options.includes(i)) return void this.debug.warn(`Disabled value of '${i}' for ${e}`)
                }
                if (qe.element(l) || (l = a && a.querySelector("[role=\"menu\"]")), !!qe.element(l)) {
                    const t = this.elements.settings.buttons[e].querySelector(`.${this.config.classNames.menu.value}`);
                    t.innerHTML = $e.getLabel.call(this, e, i);
                    const n = l && l.querySelector(`[value="${i}"]`);
                    qe.element(n) && (n.checked = !0)
                }
            },
            getLabel(e, t) {
                switch (e) {
                    case "speed":
                        return 1 === t ? Ke.get("normal", this.config) : `${t}&times;`;
                    case "quality":
                        if (qe.number(t)) {
                            const e = Ke.get(`qualityLabel.${t}`, this.config);
                            return e.length ? e : `${t}p`
                        }
                        return je(t);
                    case "captions":
                        return Je.getLabel.call(this);
                    default:
                        return null;
                }
            },
            setQualityMenu(e) {
                if (!qe.element(this.elements.settings.panels.quality)) return;
                const t = this.elements.settings.panels.quality.querySelector("[role=\"menu\"]");
                qe.array(e) && (this.options.quality = V(e).filter(e => this.config.quality.options.includes(e)));
                const n = !qe.empty(this.options.quality) && 1 < this.options.quality.length;
                if ($e.toggleMenuButton.call(this, "quality", n), C(t), $e.checkMenu.call(this), !n) return;
                const a = e => {
                    const t = Ke.get(`qualityBadge.${e}`, this.config);
                    return t.length ? $e.createBadge.call(this, t) : null
                };
                this.options.quality.sort((e, t) => {
                    const n = this.config.quality.options;
                    return n.indexOf(e) > n.indexOf(t) ? 1 : -1
                }).forEach(e => {
                    $e.createMenuItem.call(this, {
                        value: e,
                        list: t,
                        type: "quality",
                        title: $e.getLabel.call(this, "quality", e),
                        badge: a(e)
                    })
                }), $e.updateSetting.call(this, "quality", t)
            },
            setCaptionsMenu() {
                if (!qe.element(this.elements.settings.panels.captions)) return;
                const e = this.elements.settings.panels.captions.querySelector("[role=\"menu\"]"),
                    t = Je.getTracks.call(this),
                    n = !!t.length;
                if ($e.toggleMenuButton.call(this, "captions", n), C(e), $e.checkMenu.call(this), !!n) {
                    const n = t.map((t, n) => ({
                        value: n,
                        checked: this.captions.toggled && this.currentTrack === n,
                        title: Je.getLabel.call(this, t),
                        badge: t.language && $e.createBadge.call(this, t.language.toUpperCase()),
                        list: e,
                        type: "language"
                    }));
                    n.unshift({
                        value: -1,
                        checked: !this.captions.toggled,
                        title: Ke.get("disabled", this.config),
                        list: e,
                        type: "language"
                    }), n.forEach($e.createMenuItem.bind(this)), $e.updateSetting.call(this, "captions", e)
                }
            },
            setSpeedMenu() {
                if (!qe.element(this.elements.settings.panels.speed)) return;
                const e = this.elements.settings.panels.speed.querySelector("[role=\"menu\"]");
                this.options.speed = this.options.speed.filter(e => e >= this.minimumSpeed && e <= this.maximumSpeed);
                const t = !qe.empty(this.options.speed) && 1 < this.options.speed.length;
                $e.toggleMenuButton.call(this, "speed", t), C(e), $e.checkMenu.call(this), t && (this.options.speed.forEach(t => {
                    $e.createMenuItem.call(this, {
                        value: t,
                        list: e,
                        type: "speed",
                        title: $e.getLabel.call(this, "speed", t)
                    })
                }), $e.updateSetting.call(this, "speed", e))
            },
            checkMenu() {
                const {
                    buttons: e
                } = this.elements.settings, t = !qe.empty(e) && Object.values(e).some(e => !e.hidden);
                S(this.elements.settings.menu, !t)
            },
            focusFirstMenuItem(e, t = !1) {
                if (this.elements.settings.popup.hidden) return;
                let n = e;
                qe.element(n) || (n = Object.values(this.elements.settings.panels).find(e => !e.hidden));
                const a = n.querySelector("[role^=\"menuitem\"]");
                _.call(this, a, t)
            },
            toggleMenu(e) {
                const {
                    popup: t
                } = this.elements.settings, n = this.elements.buttons.settings;
                if (!qe.element(t) || !qe.element(n)) return;
                const {
                    hidden: a
                } = t;
                let i = a;
                if (qe.boolean(e)) i = e;
                else if (qe.keyboardEvent(e) && "Escape" === e.key) i = !1;
                else if (qe.event(e)) {
                    const a = qe.function(e.composedPath) ? e.composedPath()[0] : e.target,
                        l = t.contains(a);
                    if (l || !l && e.target !== n && i) return
                }
                n.setAttribute("aria-expanded", i), S(t, !i), P(this.elements.container, this.config.classNames.menu.open, i), i && qe.keyboardEvent(e) ? $e.focusFirstMenuItem.call(this, null, !0) : !i && !a && _.call(this, n, qe.keyboardEvent(e))
            },
            getMenuSize(e) {
                const t = e.cloneNode(!0);
                t.style.position = "absolute", t.style.opacity = 0, t.removeAttribute("hidden"), e.parentNode.appendChild(t);
                const n = t.scrollWidth,
                    a = t.scrollHeight;
                return w(t), {
                    width: n,
                    height: a
                }
            },
            showMenuPanel(e = "", n = !1) {
                const a = this.elements.container.querySelector(`#plyr-settings-${this.id}-${e}`);
                if (!qe.element(a)) return;
                const i = a.parentNode,
                    l = Array.from(i.children).find(e => !e.hidden);
                if (Ve.transitions && !Ve.reducedMotion) {
                    i.style.width = `${l.scrollWidth}px`, i.style.height = `${l.scrollHeight}px`;
                    const e = $e.getMenuSize.call(this, a),
                        n = e => {
                            e.target === i && ["width", "height"].includes(e.propertyName) && (i.style.width = "", i.style.height = "", t.call(this, i, De, n))
                        };
                    q.call(this, i, De, n), i.style.width = `${e.width}px`, i.style.height = `${e.height}px`
                }
                S(l, !0), S(a, !1), $e.focusFirstMenuItem.call(this, a, n)
            },
            setDownloadUrl() {
                const e = this.elements.buttons.download;
                qe.element(e) && e.setAttribute("href", this.download)
            },
            create(e) {
                const {
                    bindMenuItemShortcuts: t,
                    createButton: n,
                    createProgress: a,
                    createRange: i,
                    createTime: l,
                    setQualityMenu: o,
                    setSpeedMenu: s,
                    showMenuPanel: r
                } = $e;
                this.elements.controls = null, qe.array(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(n.call(this, "play-large"));
                const d = v("div", E(this.config.selectors.controls.wrapper));
                this.elements.controls = d;
                const c = {
                    class: "plyr__controls__item"
                };
                return V(qe.array(this.config.controls) ? this.config.controls : []).forEach(o => {
                    if ("restart" === o && d.appendChild(n.call(this, "restart", c)), "rewind" === o && d.appendChild(n.call(this, "rewind", c)), "play" === o && d.appendChild(n.call(this, "play", c)), "fast-forward" === o && d.appendChild(n.call(this, "fast-forward", c)), "progress" === o) {
                        const t = v("div", {
                                class: `${c.class} plyr__progress__container`
                            }),
                            n = v("div", E(this.config.selectors.progress));
                        if (n.appendChild(i.call(this, "seek", {
                                id: `plyr-seek-${e.id}`
                            })), n.appendChild(a.call(this, "buffer")), this.config.tooltips.seek) {
                            const e = v("span", {
                                class: this.config.classNames.tooltip
                            }, "00:00");
                            n.appendChild(e), this.elements.display.seekTooltip = e
                        }
                        this.elements.progress = n, t.appendChild(this.elements.progress), d.appendChild(t)
                    }
                    if ("current-time" === o && d.appendChild(l.call(this, "currentTime", c)), "duration" === o && d.appendChild(l.call(this, "duration", c)), "mute" === o || "volume" === o) {
                        let {
                            volume: t
                        } = this.elements;
                        if (qe.element(t) && d.contains(t) || (t = v("div", y({}, c, {
                                class: `${c.class} plyr__volume`.trim()
                            })), this.elements.volume = t, d.appendChild(t)), "mute" === o && t.appendChild(n.call(this, "mute")), "volume" === o && !Fe.isIos) {
                            const n = {
                                max: 1,
                                step: .05,
                                value: this.config.volume
                            };
                            t.appendChild(i.call(this, "volume", y(n, {
                                id: `plyr-volume-${e.id}`
                            })))
                        }
                    }
                    if ("captions" === o && d.appendChild(n.call(this, "captions", c)), "settings" === o && !qe.empty(this.config.settings)) {
                        const a = v("div", y({}, c, {
                            class: `${c.class} plyr__menu`.trim(),
                            hidden: ""
                        }));
                        a.appendChild(n.call(this, "settings", {
                            "aria-haspopup": !0,
                            "aria-controls": `plyr-settings-${e.id}`,
                            "aria-expanded": !1
                        }));
                        const i = v("div", {
                                class: "plyr__menu__container",
                                id: `plyr-settings-${e.id}`,
                                hidden: ""
                            }),
                            l = v("div"),
                            o = v("div", {
                                id: `plyr-settings-${e.id}-home`
                            }),
                            s = v("div", {
                                role: "menu"
                            });
                        o.appendChild(s), l.appendChild(o), this.elements.settings.panels.home = o, this.config.settings.forEach(n => {
                            const a = v("button", y(E(this.config.selectors.buttons.settings), {
                                type: "button",
                                class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,
                                role: "menuitem",
                                "aria-haspopup": !0,
                                hidden: ""
                            }));
                            t.call(this, a, n), q.call(this, a, "click", () => {
                                r.call(this, n, !1)
                            });
                            const i = v("span", null, Ke.get(n, this.config)),
                                o = v("span", {
                                    class: this.config.classNames.menu.value
                                });
                            o.innerHTML = e[n], i.appendChild(o), a.appendChild(i), s.appendChild(a);
                            const d = v("div", {
                                    id: `plyr-settings-${e.id}-${n}`,
                                    hidden: ""
                                }),
                                c = v("button", {
                                    type: "button",
                                    class: `${this.config.classNames.control} ${this.config.classNames.control}--back`
                                });
                            c.appendChild(v("span", {
                                "aria-hidden": !0
                            }, Ke.get(n, this.config))), c.appendChild(v("span", {
                                class: this.config.classNames.hidden
                            }, Ke.get("menuBack", this.config))), q.call(this, d, "keydown", e => {
                                "ArrowLeft" !== e.key || (e.preventDefault(), e.stopPropagation(), r.call(this, "home", !0))
                            }, !1), q.call(this, c, "click", () => {
                                r.call(this, "home", !1)
                            }), d.appendChild(c), d.appendChild(v("div", {
                                role: "menu"
                            })), l.appendChild(d), this.elements.settings.buttons[n] = a, this.elements.settings.panels[n] = d
                        }), i.appendChild(l), a.appendChild(i), d.appendChild(a), this.elements.settings.popup = i, this.elements.settings.menu = a
                    }
                    if ("pip" === o && Ve.pip && d.appendChild(n.call(this, "pip", c)), "airplay" === o && Ve.airplay && d.appendChild(n.call(this, "airplay", c)), "download" === o) {
                        const e = y({}, c, {
                            element: "a",
                            href: this.download,
                            target: "_blank"
                        });
                        this.isHTML5 && (e.download = "");
                        const {
                            download: t
                        } = this.config.urls;
                        !qe.url(t) && this.isEmbed && y(e, {
                            icon: `logo-${this.provider}`,
                            label: this.provider
                        }), d.appendChild(n.call(this, "download", e))
                    }
                    "fullscreen" === o && d.appendChild(n.call(this, "fullscreen", c))
                }), this.isHTML5 && o.call(this, Oe.getQualityOptions.call(this)), s.call(this), d
            },
            inject() {
                if (this.config.loadSprite) {
                    const e = $e.getIconUrl.call(this);
                    e.cors && ne(e.url, "sprite-plyr")
                }
                this.id = Math.floor(1e4 * Math.random());
                let e = null;
                this.elements.controls = null;
                const t = {
                    id: this.id,
                    seektime: this.config.seekTime,
                    title: this.config.title
                };
                let n = !0;
                qe.function(this.config.controls) && (this.config.controls = this.config.controls.call(this, t)), this.config.controls || (this.config.controls = []), qe.element(this.config.controls) || qe.string(this.config.controls) ? e = this.config.controls : (e = $e.create.call(this, {
                    id: this.id,
                    seektime: this.config.seekTime,
                    speed: this.speed,
                    quality: this.quality,
                    captions: Je.getLabel.call(this)
                }), n = !1);
                n && qe.string(this.config.controls) && (e = (e => {
                    let n = e;
                    return Object.entries(t).forEach(([e, t]) => {
                        n = ze(n, `{${e}}`, t)
                    }), n
                })(e));
                let a;
                qe.string(this.config.selectors.controls.container) && (a = document.querySelector(this.config.selectors.controls.container)), qe.element(a) || (a = this.elements.container);
                const i = qe.element(e) ? "insertAdjacentElement" : "insertAdjacentHTML";
                if (a[i]("afterbegin", e), qe.element(this.elements.controls) || $e.findElements.call(this), !qe.empty(this.elements.buttons)) {
                    const e = e => {
                        const t = this.config.classNames.controlPressed;
                        e.setAttribute("aria-pressed", "false"), Object.defineProperty(e, "pressed", {
                            configurable: !0,
                            enumerable: !0,
                            get() {
                                return x(e, t)
                            },
                            set(n = !1) {
                                P(e, t, n), e.setAttribute("aria-pressed", n ? "true" : "false")
                            }
                        })
                    };
                    Object.values(this.elements.buttons).filter(Boolean).forEach(t => {
                        qe.array(t) || qe.nodeList(t) ? Array.from(t).filter(Boolean).forEach(e) : e(t)
                    })
                }
                if (Fe.isEdge && g(a), this.config.tooltips.controls) {
                    const {
                        classNames: e,
                        selectors: t
                    } = this.config, n = `${t.controls.wrapper} ${t.labels} .${e.hidden}`, a = M.call(this, n);
                    Array.from(a).forEach(e => {
                        P(e, this.config.classNames.hidden, !1), P(e, this.config.classNames.tooltip, !0)
                    })
                }
            },
            setMediaMetadata() {
                try {
                    "mediaSession" in navigator && (navigator.mediaSession.metadata = new window.MediaMetadata({
                        title: this.config.mediaMetadata.title,
                        artist: this.config.mediaMetadata.artist,
                        album: this.config.mediaMetadata.album,
                        artwork: this.config.mediaMetadata.artwork
                    }))
                } catch (e) {}
            },
            setMarkers() {
                var e, t;
                if (!this.duration || this.elements.markers) return;
                const n = null === (e = this.config.markers) || void 0 === e || null === (t = e.points) || void 0 === t ? void 0 : t.filter(({
                    time: e
                }) => 0 < e && e < this.duration);
                if (!(null !== n && void 0 !== n && n.length)) return;
                const a = document.createDocumentFragment(),
                    i = document.createDocumentFragment();
                let l = null;
                const o = `${this.config.classNames.tooltip}--visible`,
                    s = e => P(l, o, e);
                n.forEach(e => {
                    const t = v("span", {
                            class: this.config.classNames.marker
                        }, ""),
                        n = `${100*(e.time/this.duration)}%`;
                    l && (t.addEventListener("mouseenter", () => {
                        e.label || (l.style.left = n, l.innerHTML = e.label, s(!0))
                    }), t.addEventListener("mouseleave", () => {
                        s(!1)
                    })), t.addEventListener("click", () => {
                        this.currentTime = e.time
                    }), t.style.left = n, i.appendChild(t)
                }), a.appendChild(i), this.config.tooltips.seek || (l = v("span", {
                    class: this.config.classNames.tooltip
                }, ""), a.appendChild(l)), this.elements.markers = {
                    points: i,
                    tip: l
                }, this.elements.progress.appendChild(a)
            }
        },
        Je = {
            setup() {
                if (!this.supported.ui) return;
                if (!this.isVideo || this.isYouTube || this.isHTML5 && !Ve.textTracks) return void(qe.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && $e.setCaptionsMenu.call(this));
                if (qe.element(this.elements.captions) || (this.elements.captions = v("div", E(this.config.selectors.captions)), this.elements.captions.setAttribute("dir", "auto"), k(this.elements.captions, this.elements.wrapper)), Fe.isIE && window.URL) {
                    const e = this.media.querySelectorAll("track");
                    Array.from(e).forEach(e => {
                        const t = e.getAttribute("src"),
                            n = ie(t);
                        null !== n && n.hostname !== window.location.href.hostname && ["http:", "https:"].includes(n.protocol) && te(t, "blob").then(t => {
                            e.setAttribute("src", window.URL.createObjectURL(t))
                        }).catch(() => {
                            w(e)
                        })
                    })
                }
                const e = navigator.languages || [navigator.language || navigator.userLanguage || "en"],
                    t = V(e.map(e => e.split("-")[0]));
                let n = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase();
                "auto" === n && ([n] = t);
                let a = this.storage.get("captions");
                if (qe.boolean(a) || ({
                        active: a
                    } = this.config.captions), Object.assign(this.captions, {
                        toggled: !1,
                        active: a,
                        language: n,
                        languages: t
                    }), this.isHTML5) {
                    const e = this.config.captions.update ? "addtrack removetrack" : "removetrack";
                    q.call(this, this.media.textTracks, e, Je.update.bind(this))
                }
                setTimeout(Je.update.bind(this), 0)
            },
            update() {
                const e = Je.getTracks.call(this, !0),
                    {
                        active: t,
                        language: n,
                        meta: a,
                        currentTrackNode: i
                    } = this.captions,
                    l = !!e.find(e => e.language === n);
                this.isHTML5 && this.isVideo && e.filter(e => !a.get(e)).forEach(e => {
                    this.debug.log("Track added", e), a.set(e, {
                        default: "showing" === e.mode
                    }), "showing" === e.mode && (e.mode = "hidden"), q.call(this, e, "cuechange", () => Je.updateCues.call(this))
                }), (l && this.language !== n || !e.includes(i)) && (Je.setLanguage.call(this, n), Je.toggle.call(this, t && l)), this.elements && P(this.elements.container, this.config.classNames.captions.enabled, !qe.empty(e)), qe.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && $e.setCaptionsMenu.call(this)
            },
            toggle(e, t = !0) {
                if (!this.supported.ui) return;
                const {
                    toggled: n
                } = this.captions, a = this.config.classNames.captions.active, i = qe.nullOrUndefined(e) ? !n : e;
                if (i !== n) {
                    if (t || (this.captions.active = i, this.storage.set({
                            captions: i
                        })), !this.language && i && !t) {
                        const e = Je.getTracks.call(this),
                            t = Je.findTrack.call(this, [this.captions.language, ...this.captions.languages], !0);
                        return this.captions.language = t.language, void Je.set.call(this, e.indexOf(t))
                    }
                    this.elements.buttons.captions && (this.elements.buttons.captions.pressed = i), P(this.elements.container, a, i), this.captions.toggled = i, $e.updateSetting.call(this, "captions"), r.call(this, this.media, i ? "captionsenabled" : "captionsdisabled")
                }
                setTimeout(() => {
                    i && this.captions.toggled && (this.captions.currentTrackNode.mode = "hidden")
                })
            },
            set(e, t = !0) {
                const n = Je.getTracks.call(this);
                if (-1 === e) return void Je.toggle.call(this, !1, t);
                if (!qe.number(e)) return void this.debug.warn("Invalid caption argument", e);
                if (!(e in n)) return void this.debug.warn("Track not found", e);
                if (this.captions.currentTrack !== e) {
                    this.captions.currentTrack = e;
                    const a = n[e],
                        {
                            language: i
                        } = a || {};
                    this.captions.currentTrackNode = a, $e.updateSetting.call(this, "captions"), t || (this.captions.language = i, this.storage.set({
                        language: i
                    })), this.isVimeo && this.embed.enableTextTrack(i), r.call(this, this.media, "languagechange")
                }
                Je.toggle.call(this, !0, t), this.isHTML5 && this.isVideo && Je.updateCues.call(this)
            },
            setLanguage(e, t = !0) {
                if (!qe.string(e)) return void this.debug.warn("Invalid language argument", e);
                const n = e.toLowerCase();
                this.captions.language = n;
                const a = Je.getTracks.call(this),
                    i = Je.findTrack.call(this, [n]);
                Je.set.call(this, a.indexOf(i), t)
            },
            getTracks(e = !1) {
                const t = Array.from((this.media || {}).textTracks || []);
                return t.filter(t => !this.isHTML5 || e || this.captions.meta.has(t)).filter(e => ["captions", "subtitles"].includes(e.kind))
            },
            findTrack(e, t = !1) {
                const n = Je.getTracks.call(this),
                    i = e => +(this.captions.meta.get(e) || {}).default,
                    l = Array.from(n).sort((e, t) => i(t) - i(e));
                let o;
                return e.every(e => (o = l.find(n => n.language === e), !o)), o || (t ? l[0] : void 0)
            },
            getCurrentTrack() {
                return Je.getTracks.call(this)[this.currentTrack]
            },
            getLabel(e) {
                let t = e;
                return !qe.track(t) && Ve.textTracks && this.captions.toggled && (t = Je.getCurrentTrack.call(this)), qe.track(t) ? qe.empty(t.label) ? qe.empty(t.language) ? Ke.get("enabled", this.config) : e.language.toUpperCase() : t.label : Ke.get("disabled", this.config)
            },
            updateCues(e) {
                if (!this.supported.ui) return;
                if (!qe.element(this.elements.captions)) return void this.debug.warn("No captions element to render to");
                if (!qe.nullOrUndefined(e) && !Array.isArray(e)) return void this.debug.warn("updateCues: Invalid input", e);
                let t = e;
                if (!t) {
                    const e = Je.getCurrentTrack.call(this);
                    t = Array.from((e || {}).activeCues || []).map(e => e.getCueAsHTML()).map(ee)
                }
                const n = t.map(e => e.trim()).join("\n"),
                    a = n !== this.elements.captions.innerHTML;
                if (a) {
                    C(this.elements.captions);
                    const e = v("span", E(this.config.selectors.caption));
                    e.innerHTML = n, this.elements.captions.appendChild(e), r.call(this, this.media, "cuechange")
                }
            }
        },
        Ze = {
            enabled: !0,
            title: "",
            debug: !1,
            autoplay: !1,
            autopause: !0,
            playsinline: !0,
            seekTime: 10,
            volume: 1,
            muted: !1,
            duration: null,
            displayDuration: !0,
            invertTime: !0,
            toggleInvert: !0,
            ratio: null,
            clickToPlay: !0,
            hideControls: !0,
            resetOnEnd: !1,
            disableContextMenu: !0,
            loadSprite: !0,
            iconPrefix: "plyr",
            iconUrl: "https://cdn.plyr.io/3.7.3/plyr.svg",
            blankVideo: "https://cdn.plyr.io/static/blank.mp4",
            quality: {
                default: 576,
                options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
                forced: !1,
                onChange: null
            },
            loop: {
                active: !1
            },
            speed: {
                selected: 1,
                options: [.5, .75, 1, 1.25, 1.5, 1.75, 2, 4]
            },
            keyboard: {
                focused: !0,
                global: !1
            },
            tooltips: {
                controls: !1,
                seek: !0
            },
            captions: {
                active: !1,
                language: "auto",
                update: !1
            },
            fullscreen: {
                enabled: !0,
                fallback: !0,
                iosNative: !1
            },
            storage: {
                enabled: !0,
                key: "plyr"
            },
            controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"],
            settings: ["captions", "quality", "speed"],
            i18n: {
                restart: "Restart",
                rewind: "Rewind {seektime}s",
                play: "Play",
                pause: "Pause",
                fastForward: "Forward {seektime}s",
                seek: "Seek",
                seekLabel: "{currentTime} of {duration}",
                played: "Played",
                buffered: "Buffered",
                currentTime: "Current time",
                duration: "Duration",
                volume: "Volume",
                mute: "Mute",
                unmute: "Unmute",
                enableCaptions: "Enable captions",
                disableCaptions: "Disable captions",
                download: "Download",
                enterFullscreen: "Enter fullscreen",
                exitFullscreen: "Exit fullscreen",
                frameTitle: "Player for {title}",
                captions: "Captions",
                settings: "Settings",
                pip: "PIP",
                menuBack: "Go back to previous menu",
                speed: "Speed",
                normal: "Normal",
                quality: "Quality",
                loop: "Loop",
                start: "Start",
                end: "End",
                all: "All",
                reset: "Reset",
                disabled: "Disabled",
                enabled: "Enabled",
                advertisement: "Ad",
                qualityBadge: {
                    2160: "4K",
                    1440: "HD",
                    1080: "HD",
                    720: "HD",
                    576: "SD",
                    480: "SD"
                }
            },
            urls: {
                download: null,
                vimeo: {
                    sdk: "https://player.vimeo.com/api/player.js",
                    iframe: "https://player.vimeo.com/video/{0}?{1}",
                    api: "https://vimeo.com/api/oembed.json?url={0}"
                },
                youtube: {
                    sdk: "https://www.youtube.com/iframe_api",
                    api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}"
                },
                googleIMA: {
                    sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js"
                }
            },
            listeners: {
                seek: null,
                play: null,
                pause: null,
                restart: null,
                rewind: null,
                fastForward: null,
                mute: null,
                volume: null,
                captions: null,
                download: null,
                fullscreen: null,
                pip: null,
                airplay: null,
                speed: null,
                quality: null,
                loop: null,
                language: null
            },
            events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "download", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"],
            selectors: {
                editable: "input, textarea, select, [contenteditable]",
                container: ".plyr",
                controls: {
                    container: null,
                    wrapper: ".plyr__controls"
                },
                labels: "[data-plyr]",
                buttons: {
                    play: "[data-plyr=\"play\"]",
                    pause: "[data-plyr=\"pause\"]",
                    restart: "[data-plyr=\"restart\"]",
                    rewind: "[data-plyr=\"rewind\"]",
                    fastForward: "[data-plyr=\"fast-forward\"]",
                    mute: "[data-plyr=\"mute\"]",
                    captions: "[data-plyr=\"captions\"]",
                    download: "[data-plyr=\"download\"]",
                    fullscreen: "[data-plyr=\"fullscreen\"]",
                    pip: "[data-plyr=\"pip\"]",
                    airplay: "[data-plyr=\"airplay\"]",
                    settings: "[data-plyr=\"settings\"]",
                    loop: "[data-plyr=\"loop\"]"
                },
                inputs: {
                    seek: "[data-plyr=\"seek\"]",
                    volume: "[data-plyr=\"volume\"]",
                    speed: "[data-plyr=\"speed\"]",
                    language: "[data-plyr=\"language\"]",
                    quality: "[data-plyr=\"quality\"]"
                },
                display: {
                    currentTime: ".plyr__time--current",
                    duration: ".plyr__time--duration",
                    buffer: ".plyr__progress__buffer",
                    loop: ".plyr__progress__loop",
                    volume: ".plyr__volume--display"
                },
                progress: ".plyr__progress",
                captions: ".plyr__captions",
                caption: ".plyr__caption"
            },
            classNames: {
                type: "plyr--{0}",
                provider: "plyr--{0}",
                video: "plyr__video-wrapper",
                embed: "plyr__video-embed",
                videoFixedRatio: "plyr__video-wrapper--fixed-ratio",
                embedContainer: "plyr__video-embed__container",
                poster: "plyr__poster",
                posterEnabled: "plyr__poster-enabled",
                ads: "plyr__ads",
                control: "plyr__control",
                controlPressed: "plyr__control--pressed",
                playing: "plyr--playing",
                paused: "plyr--paused",
                stopped: "plyr--stopped",
                loading: "plyr--loading",
                hover: "plyr--hover",
                tooltip: "plyr__tooltip",
                cues: "plyr__cues",
                marker: "plyr__progress__marker",
                hidden: "plyr__sr-only",
                hideControls: "plyr--hide-controls",
                isIos: "plyr--is-ios",
                isTouch: "plyr--is-touch",
                uiSupported: "plyr--full-ui",
                noTransition: "plyr--no-transition",
                display: {
                    time: "plyr__time"
                },
                menu: {
                    value: "plyr__menu__value",
                    badge: "plyr__badge",
                    open: "plyr--menu-open"
                },
                captions: {
                    enabled: "plyr--captions-enabled",
                    active: "plyr--captions-active"
                },
                fullscreen: {
                    enabled: "plyr--fullscreen-enabled",
                    fallback: "plyr--fullscreen-fallback"
                },
                pip: {
                    supported: "plyr--pip-supported",
                    active: "plyr--pip-active"
                },
                airplay: {
                    supported: "plyr--airplay-supported",
                    active: "plyr--airplay-active"
                },
                tabFocus: "plyr__tab-focus",
                previewThumbnails: {
                    thumbContainer: "plyr__preview-thumb",
                    thumbContainerShown: "plyr__preview-thumb--is-shown",
                    imageContainer: "plyr__preview-thumb__image-container",
                    timeContainer: "plyr__preview-thumb__time-container",
                    scrubbingContainer: "plyr__preview-scrubbing",
                    scrubbingContainerShown: "plyr__preview-scrubbing--is-shown"
                }
            },
            attributes: {
                embed: {
                    provider: "data-plyr-provider",
                    id: "data-plyr-embed-id",
                    hash: "data-plyr-embed-hash"
                }
            },
            ads: {
                enabled: !1,
                publisherId: "",
                tagUrl: ""
            },
            previewThumbnails: {
                enabled: !1,
                src: ""
            },
            vimeo: {
                byline: !1,
                portrait: !1,
                title: !1,
                speed: !0,
                transparent: !1,
                customControls: !0,
                referrerPolicy: null,
                premium: !1
            },
            youtube: {
                rel: 0,
                showinfo: 0,
                iv_load_policy: 3,
                modestbranding: 1,
                customControls: !0,
                noCookie: !1
            },
            mediaMetadata: {
                title: "",
                artist: "",
                album: "",
                artwork: []
            },
            markers: {
                enabled: !1,
                points: []
            }
        },
        et = {
            active: "picture-in-picture",
            inactive: "inline"
        },
        tt = {
            html5: "html5",
            youtube: "youtube",
            vimeo: "vimeo"
        },
        nt = {
            audio: "audio",
            video: "video"
        },
        at = () => {};
    class it {
        constructor(e = !1) {
            this.enabled = window.console && e, this.enabled && this.log("Debugging enabled")
        }
        get log() {
            return this.enabled ? Function.prototype.bind.call(console.log, console) : at
        }
        get warn() {
            return this.enabled ? Function.prototype.bind.call(console.warn, console) : at
        }
        get error() {
            return this.enabled ? Function.prototype.bind.call(console.error, console) : at
        }
    }
    class lt {
        constructor(t) {
            e(this, "onChange", () => {
                if (this.enabled) {
                    const e = this.player.elements.buttons.fullscreen;
                    qe.element(e) && (e.pressed = this.active);
                    const t = this.target === this.player.media ? this.target : this.player.elements.container;
                    r.call(this.player, t, this.active ? "enterfullscreen" : "exitfullscreen", !0)
                }
            }), e(this, "toggleFallback", (e = !1) => {
                if (e ? this.scrollPosition = {
                        x: window.scrollX || 0,
                        y: window.scrollY || 0
                    } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = e ? "hidden" : "", P(this.target, this.player.config.classNames.fullscreen.fallback, e), Fe.isIos) {
                    let t = document.head.querySelector("meta[name=\"viewport\"]");
                    t || (t = document.createElement("meta"), t.setAttribute("name", "viewport"));
                    const n = qe.string(t.content) && t.content.includes("viewport-fit=cover");
                    e ? (this.cleanupViewport = !n, !n && (t.content += `,${"viewport-fit=cover"}`)) : this.cleanupViewport && (t.content = t.content.split(",").filter(e => e.trim() !== "viewport-fit=cover").join(","))
                }
                this.onChange()
            }), e(this, "trapFocus", e => {
                if (Fe.isIos || !this.active || "Tab" !== e.key) return;
                const t = document.activeElement,
                    n = M.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"),
                    [a] = n,
                    i = n[n.length - 1];
                t !== i || e.shiftKey ? t === a && e.shiftKey && (i.focus(), e.preventDefault()) : (a.focus(), e.preventDefault())
            }), e(this, "update", () => {
                if (this.enabled) {
                    let e;
                    e = this.forceFallback ? "Fallback (forced)" : lt.native ? "Native" : "Fallback", this.player.debug.log(`${e} fullscreen enabled`)
                } else this.player.debug.log("Fullscreen not supported and fallback disabled");
                P(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled)
            }), e(this, "enter", () => {
                this.enabled && (Fe.isIos && this.player.config.fullscreen.iosNative ? this.player.isVimeo ? this.player.embed.requestFullscreen() : this.target.webkitEnterFullscreen() : !lt.native || this.forceFallback ? this.toggleFallback(!0) : this.prefix ? !qe.empty(this.prefix) && this.target[`${this.prefix}Request${this.property}`]() : this.target.requestFullscreen({
                    navigationUI: "hide"
                }))
            }), e(this, "exit", () => {
                if (this.enabled)
                    if (Fe.isIos && this.player.config.fullscreen.iosNative) this.target.webkitExitFullscreen(), R(this.player.play());
                    else if (!lt.native || this.forceFallback) this.toggleFallback(!1);
                else if (!this.prefix)(document.cancelFullScreen || document.exitFullscreen).call(document);
                else if (!qe.empty(this.prefix)) {
                    const e = "moz" === this.prefix ? "Cancel" : "Exit";
                    document[`${this.prefix}${e}${this.property}`]()
                }
            }), e(this, "toggle", () => {
                this.active ? this.exit() : this.enter()
            }), this.player = t, this.prefix = lt.prefix, this.property = lt.property, this.scrollPosition = {
                x: 0,
                y: 0
            }, this.forceFallback = "force" === t.config.fullscreen.fallback, this.player.elements.fullscreen = t.config.fullscreen.container && N(this.player.elements.container, t.config.fullscreen.container), q.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : `${this.prefix}fullscreenchange`, () => {
                this.onChange()
            }), q.call(this.player, this.player.elements.container, "dblclick", e => {
                qe.element(this.player.elements.controls) && this.player.elements.controls.contains(e.target) || this.player.listeners.proxy(e, this.toggle, "fullscreen")
            }), q.call(this, this.player.elements.container, "keydown", e => this.trapFocus(e)), this.update()
        }
        static get native() {
            return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)
        }
        get usingNative() {
            return lt.native && !this.forceFallback
        }
        static get prefix() {
            if (qe.function(document.exitFullscreen)) return "";
            let e = "";
            return ["webkit", "moz", "ms"].some(t => !!(qe.function(document[`${t}ExitFullscreen`]) || qe.function(document[`${t}CancelFullScreen`])) && (e = t, !0)), e
        }
        static get property() {
            return "moz" === this.prefix ? "FullScreen" : "Fullscreen"
        }
        get enabled() {
            return (lt.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo
        }
        get active() {
            if (!this.enabled) return !1;
            if (!lt.native || this.forceFallback) return x(this.target, this.player.config.classNames.fullscreen.fallback);
            const e = this.prefix ? this.target.getRootNode()[`${this.prefix}${this.property}Element`] : this.target.getRootNode().fullscreenElement;
            return e && e.shadowRoot ? e === this.target.getRootNode().host : e === this.target
        }
        get target() {
            return Fe.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container
        }
    }
    const ot = {
        addStyleHook() {
            P(this.elements.container, this.config.selectors.container.replace(".", ""), !0), P(this.elements.container, this.config.classNames.uiSupported, this.supported.ui)
        },
        toggleNativeControls(e = !1) {
            e && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls")
        },
        build() {
            return this.listeners.media(), this.supported.ui ? void(!qe.element(this.elements.controls) && ($e.inject.call(this), this.listeners.controls()), ot.toggleNativeControls.call(this), this.isHTML5 && Je.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, $e.updateVolume.call(this), $e.timeUpdate.call(this), $e.durationUpdate.call(this), ot.checkPlaying.call(this), P(this.elements.container, this.config.classNames.pip.supported, Ve.pip && this.isHTML5 && this.isVideo), P(this.elements.container, this.config.classNames.airplay.supported, Ve.airplay && this.isHTML5), P(this.elements.container, this.config.classNames.isIos, Fe.isIos), P(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout(() => {
                r.call(this, this.media, "ready")
            }, 0), ot.setTitle.call(this), this.poster && ot.setPoster.call(this, this.poster, !1).catch(() => {}), this.config.duration && $e.durationUpdate.call(this), this.config.mediaMetadata && $e.setMediaMetadata.call(this)) : (this.debug.warn(`Basic support only for ${this.provider} ${this.type}`), void ot.toggleNativeControls.call(this, !0))
        },
        setTitle() {
            let e = Ke.get("play", this.config);
            if (qe.string(this.config.title) && !qe.empty(this.config.title) && (e += `, ${this.config.title}`), Array.from(this.elements.buttons.play || []).forEach(t => {
                    t.setAttribute("aria-label", e)
                }), this.isEmbed) {
                const e = I.call(this, "iframe");
                if (!qe.element(e)) return;
                const t = qe.empty(this.config.title) ? "video" : this.config.title,
                    n = Ke.get("frameTitle", this.config);
                e.setAttribute("title", n.replace("{title}", t))
            }
        },
        togglePoster(e) {
            P(this.elements.container, this.config.classNames.posterEnabled, e)
        },
        setPoster(e, t = !0) {
            return t && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", e), this.elements.poster.removeAttribute("hidden"), F.call(this).then(() => se(e)).catch(t => {
                throw e === this.poster && ot.togglePoster.call(this, !1), t
            }).then(() => {
                if (e !== this.poster) throw new Error("setPoster cancelled by later call to setPoster")
            }).then(() => (Object.assign(this.elements.poster.style, {
                backgroundImage: `url('${e}')`,
                backgroundSize: ""
            }), ot.togglePoster.call(this, !0), e)))
        },
        checkPlaying(e) {
            P(this.elements.container, this.config.classNames.playing, this.playing), P(this.elements.container, this.config.classNames.paused, this.paused), P(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach(e => {
                Object.assign(e, {
                    pressed: this.playing
                }), e.setAttribute("aria-label", Ke.get(this.playing ? "pause" : "play", this.config))
            }), qe.event(e) && "timeupdate" === e.type || ot.toggleControls.call(this)
        },
        checkLoading(e) {
            this.loading = ["stalled", "waiting"].includes(e.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout(() => {
                P(this.elements.container, this.config.classNames.loading, this.loading), ot.toggleControls.call(this)
            }, this.loading ? 250 : 0)
        },
        toggleControls(e) {
            const {
                controls: t
            } = this.elements;
            if (t && this.config.hideControls) {
                const n = this.touch && this.lastSeekTime + 2e3 > Date.now();
                this.toggleControls(!!(e || this.loading || this.paused || t.pressed || t.hover || n))
            }
        },
        migrateStyles() {
            Object.values({ ...this.media.style
            }).filter(e => !qe.empty(e) && qe.string(e) && e.startsWith("--plyr")).forEach(e => {
                this.elements.container.style.setProperty(e, this.media.style.getPropertyValue(e)), this.media.style.removeProperty(e)
            }), qe.empty(this.media.style) && this.media.removeAttribute("style")
        }
    };
    class st {
        constructor(a) {
            e(this, "firstTouch", () => {
                const {
                    player: e
                } = this, {
                    elements: t
                } = e;
                e.touch = !0, P(t.container, e.config.classNames.isTouch, !0)
            }), e(this, "setTabFocus", e => {
                const {
                    player: t
                } = this, {
                    elements: n
                } = t, {
                    key: a,
                    type: i,
                    timeStamp: l
                } = e;
                if (clearTimeout(this.focusTimer), "keydown" === i && "Tab" !== a) return;
                "keydown" === i && (this.lastKeyDown = l);
                const o = 20 >= l - this.lastKeyDown;
                ("focus" !== i || o) && ((() => {
                    const e = t.config.classNames.tabFocus,
                        n = M.call(t, `.${e}`);
                    P(n, e, !1)
                })(), "focusout" !== i && (this.focusTimer = setTimeout(() => {
                    const e = document.activeElement;
                    n.container.contains(e) && P(document.activeElement, t.config.classNames.tabFocus, !0)
                }, 10)))
            }), e(this, "global", (e = !0) => {
                const {
                    player: t
                } = this;
                t.config.keyboard.global && H.call(t, window, "keydown keyup", this.handleKey, e, !1), H.call(t, document.body, "click", this.toggleMenu, e), n.call(t, document.body, "touchstart", this.firstTouch), H.call(t, document.body, "keydown focus blur focusout", this.setTabFocus, e, !1, !0)
            }), e(this, "container", () => {
                const {
                    player: e
                } = this, {
                    config: n,
                    elements: a,
                    timers: i
                } = e;
                !n.keyboard.global && n.keyboard.focused && q.call(e, a.container, "keydown keyup", this.handleKey, !1), q.call(e, a.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", t => {
                    const {
                        controls: n
                    } = a;
                    n && "enterfullscreen" === t.type && (n.pressed = !1, n.hover = !1);
                    const l = ["touchstart", "touchmove", "mousemove"].includes(t.type);
                    let o = 0;
                    l && (ot.toggleControls.call(e, !0), o = e.touch ? 3e3 : 2e3), clearTimeout(i.controls), i.controls = setTimeout(() => ot.toggleControls.call(e, !1), o)
                });
                const l = () => {
                        if (!e.isVimeo || e.config.vimeo.premium) return;
                        const t = a.wrapper,
                            {
                                active: n
                            } = e.fullscreen,
                            [i, l] = j.call(e),
                            o = W(`aspect-ratio: ${i} / ${l}`);
                        if (!n) return void(o ? (t.style.width = null, t.style.height = null) : (t.style.maxWidth = null, t.style.margin = null));
                        const [s, r] = Y(), d = s / r > i / l;
                        o ? (t.style.width = d ? "auto" : "100%", t.style.height = d ? "100%" : "auto") : (t.style.maxWidth = d ? `${r/l*i}px` : null, t.style.margin = d ? "0 auto" : null)
                    },
                    o = () => {
                        clearTimeout(i.resized), i.resized = setTimeout(l, 50)
                    };
                q.call(e, a.container, "enterfullscreen exitfullscreen", n => {
                    const {
                        target: i
                    } = e.fullscreen;
                    if (i === a.container && (e.isEmbed || !qe.empty(e.config.ratio))) {
                        l();
                        const a = "enterfullscreen" === n.type ? q : t;
                        a.call(e, window, "resize", o)
                    }
                })
            }), e(this, "media", () => {
                const {
                    player: e
                } = this, {
                    elements: t
                } = e;
                if (q.call(e, e.media, "timeupdate seeking seeked", t => $e.timeUpdate.call(e, t)), q.call(e, e.media, "durationchange loadeddata loadedmetadata", t => $e.durationUpdate.call(e, t)), q.call(e, e.media, "ended", () => {
                        e.isHTML5 && e.isVideo && e.config.resetOnEnd && (e.restart(), e.pause())
                    }), q.call(e, e.media, "progress playing seeking seeked", t => $e.updateProgress.call(e, t)), q.call(e, e.media, "volumechange", t => $e.updateVolume.call(e, t)), q.call(e, e.media, "playing play pause ended emptied timeupdate", t => ot.checkPlaying.call(e, t)), q.call(e, e.media, "waiting canplay seeked playing", t => ot.checkLoading.call(e, t)), e.supported.ui && e.config.clickToPlay && !e.isAudio) {
                    const n = I.call(e, `.${e.config.classNames.video}`);
                    if (!qe.element(n)) return;
                    q.call(e, t.container, "click", a => {
                        const i = [t.container, n];
                        !i.includes(a.target) && !n.contains(a.target) || e.touch && e.config.hideControls || (e.ended ? (this.proxy(a, e.restart, "restart"), this.proxy(a, () => {
                            R(e.play())
                        }, "play")) : this.proxy(a, () => {
                            R(e.togglePlay())
                        }, "play"))
                    })
                }
                e.supported.ui && e.config.disableContextMenu && q.call(e, t.wrapper, "contextmenu", e => {
                    e.preventDefault()
                }, !1), q.call(e, e.media, "volumechange", () => {
                    e.storage.set({
                        volume: e.volume,
                        muted: e.muted
                    })
                }), q.call(e, e.media, "ratechange", () => {
                    $e.updateSetting.call(e, "speed"), e.storage.set({
                        speed: e.speed
                    })
                }), q.call(e, e.media, "qualitychange", t => {
                    $e.updateSetting.call(e, "quality", null, t.detail.quality)
                }), q.call(e, e.media, "ready qualitychange", () => {
                    $e.setDownloadUrl.call(e)
                });
                const n = e.config.events.concat(["keyup", "keydown"]).join(" ");
                q.call(e, e.media, n, n => {
                    let {
                        detail: a = {}
                    } = n;
                    "error" === n.type && (a = e.media.error), r.call(e, t.container, n.type, !0, a)
                })
            }), e(this, "proxy", (e, t, n) => {
                const {
                    player: a
                } = this, i = a.config.listeners[n], l = qe.function(i);
                let o = !0;
                l && (o = i.call(a, e)), !1 !== o && qe.function(t) && t.call(a, e)
            }), e(this, "bind", (e, t, n, a, i = !0) => {
                const {
                    player: l
                } = this, o = l.config.listeners[a], s = qe.function(o);
                q.call(l, e, t, e => this.proxy(e, n, a), i && !s)
            }), e(this, "controls", () => {
                const {
                    player: e
                } = this, {
                    elements: t
                } = e, n = Fe.isIE ? "change" : "input";
                if (t.buttons.play && Array.from(t.buttons.play).forEach(t => {
                        this.bind(t, "click", () => {
                            R(e.togglePlay())
                        }, "play")
                    }), this.bind(t.buttons.restart, "click", e.restart, "restart"), this.bind(t.buttons.rewind, "click", () => {
                        e.lastSeekTime = Date.now(), e.rewind()
                    }, "rewind"), this.bind(t.buttons.fastForward, "click", () => {
                        e.lastSeekTime = Date.now(), e.forward()
                    }, "fastForward"), this.bind(t.buttons.mute, "click", () => {
                        e.muted = !e.muted
                    }, "mute"), this.bind(t.buttons.captions, "click", () => e.toggleCaptions()), this.bind(t.buttons.download, "click", () => {
                        r.call(e, e.media, "download")
                    }, "download"), this.bind(t.buttons.fullscreen, "click", () => {
                        e.fullscreen.toggle()
                    }, "fullscreen"), this.bind(t.buttons.pip, "click", () => {
                        e.pip = "toggle"
                    }, "pip"), this.bind(t.buttons.airplay, "click", e.airplay, "airplay"), this.bind(t.buttons.settings, "click", t => {
                        t.stopPropagation(), t.preventDefault(), $e.toggleMenu.call(e, t)
                    }, null, !1), this.bind(t.buttons.settings, "keyup", t => [" ", "Enter"].includes(t.key) ? "Enter" === t.key ? void $e.focusFirstMenuItem.call(e, null, !0) : void(t.preventDefault(), t.stopPropagation(), $e.toggleMenu.call(e, t)) : void 0, null, !1), this.bind(t.settings.menu, "keydown", t => {
                        "Escape" === t.key && $e.toggleMenu.call(e, t)
                    }), this.bind(t.inputs.seek, "mousedown mousemove", e => {
                        const n = t.progress.getBoundingClientRect(),
                            a = 100 / n.width * (e.pageX - n.left);
                        e.currentTarget.setAttribute("seek-value", a)
                    }), this.bind(t.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", t => {
                        const n = t.currentTarget,
                            a = "play-on-seeked";
                        if (qe.keyboardEvent(t) && !["ArrowLeft", "ArrowRight"].includes(t.key)) return;
                        e.lastSeekTime = Date.now();
                        const i = n.hasAttribute(a),
                            l = ["mouseup", "touchend", "keyup"].includes(t.type);
                        i && l ? (n.removeAttribute(a), R(e.play())) : !l && e.playing && (n.setAttribute(a, ""), e.pause())
                    }), Fe.isIos) {
                    const t = M.call(e, "input[type=\"range\"]");
                    Array.from(t).forEach(e => this.bind(e, n, e => g(e.target)))
                }
                this.bind(t.inputs.seek, n, t => {
                    const n = t.currentTarget;
                    let a = n.getAttribute("seek-value");
                    qe.empty(a) && (a = n.value), n.removeAttribute("seek-value"), e.currentTime = a / n.max * e.duration
                }, "seek"), this.bind(t.progress, "mouseenter mouseleave mousemove", t => $e.updateSeekTooltip.call(e, t)), this.bind(t.progress, "mousemove touchmove", t => {
                    const {
                        previewThumbnails: n
                    } = e;
                    n && n.loaded && n.startMove(t)
                }), this.bind(t.progress, "mouseleave touchend click", () => {
                    const {
                        previewThumbnails: t
                    } = e;
                    t && t.loaded && t.endMove(!1, !0)
                }), this.bind(t.progress, "mousedown touchstart", t => {
                    const {
                        previewThumbnails: n
                    } = e;
                    n && n.loaded && n.startScrubbing(t)
                }), this.bind(t.progress, "mouseup touchend", t => {
                    const {
                        previewThumbnails: n
                    } = e;
                    n && n.loaded && n.endScrubbing(t)
                }), Fe.isWebkit && Array.from(M.call(e, "input[type=\"range\"]")).forEach(t => {
                    this.bind(t, "input", t => $e.updateRangeFill.call(e, t.target))
                }), e.config.toggleInvert && !qe.element(t.display.duration) && this.bind(t.display.currentTime, "click", () => {
                    0 === e.currentTime || (e.config.invertTime = !e.config.invertTime, $e.timeUpdate.call(e))
                }), this.bind(t.inputs.volume, n, t => {
                    e.volume = t.target.value
                }, "volume"), this.bind(t.controls, "mouseenter mouseleave", n => {
                    t.controls.hover = !e.touch && "mouseenter" === n.type
                }), t.fullscreen && Array.from(t.fullscreen.children).filter(e => !e.contains(t.container)).forEach(n => {
                    this.bind(n, "mouseenter mouseleave", n => {
                        t.controls && (t.controls.hover = !e.touch && "mouseenter" === n.type)
                    })
                }), this.bind(t.controls, "mousedown mouseup touchstart touchend touchcancel", e => {
                    t.controls.pressed = ["mousedown", "touchstart"].includes(e.type)
                }), this.bind(t.controls, "focusin", () => {
                    const {
                        config: n,
                        timers: a
                    } = e;
                    P(t.controls, n.classNames.noTransition, !0), ot.toggleControls.call(e, !0), setTimeout(() => {
                        P(t.controls, n.classNames.noTransition, !1)
                    }, 0);
                    const i = this.touch ? 3e3 : 4e3;
                    clearTimeout(a.controls), a.controls = setTimeout(() => ot.toggleControls.call(e, !1), i)
                }), this.bind(t.inputs.volume, "wheel", t => {
                    const n = t.webkitDirectionInvertedFromDevice,
                        [a, i] = [t.deltaX, -t.deltaY].map(e => n ? -e : e),
                        l = Math.sign(Math.abs(a) > Math.abs(i) ? a : i);
                    e.increaseVolume(l / 50);
                    const {
                        volume: o
                    } = e.media;
                    (1 === l && 1 > o || -1 === l && 0 < o) && t.preventDefault()
                }, "volume", !1)
            }), this.player = a, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.setTabFocus = this.setTabFocus.bind(this), this.firstTouch = this.firstTouch.bind(this)
        }
        handleKey(e) {
            const {
                player: t
            } = this, {
                elements: n
            } = t, {
                key: a,
                type: i,
                altKey: l,
                ctrlKey: o,
                metaKey: s,
                shiftKey: r
            } = e, d = "keydown" === i, c = d && a === this.lastKey;
            if (!(l || o || s || r) && a) {
                const i = e => {
                    t.currentTime = t.duration / 10 * e
                };
                if (d) {
                    const l = document.activeElement;
                    if (qe.element(l)) {
                        const {
                            editable: a
                        } = t.config.selectors, {
                            seek: i
                        } = n.inputs;
                        if (l !== i && L(l, a)) return;
                        if (" " === e.key && L(l, "button, [role^=\"menuitem\"]")) return
                    }[" ", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "c", "f", "k", "l", "m"].includes(a) && (e.preventDefault(), e.stopPropagation()), "0" === a || "1" === a || "2" === a || "3" === a || "4" === a || "5" === a || "6" === a || "7" === a || "8" === a || "9" === a ? c || i(parseInt(a, 10)) : " " === a || "k" === a ? c || R(t.togglePlay()) : "ArrowUp" === a ? t.increaseVolume(.1) : "ArrowDown" === a ? t.decreaseVolume(.1) : "m" === a ? c || (t.muted = !t.muted) : "ArrowRight" === a ? t.forward() : "ArrowLeft" === a ? t.rewind() : "f" === a ? t.fullscreen.toggle() : "c" === a ? c || t.toggleCaptions() : "l" === a ? t.loop = !t.loop : void 0, "Escape" === a && !t.fullscreen.usingNative && t.fullscreen.active && t.fullscreen.toggle(), this.lastKey = a
                } else this.lastKey = null
            }
        }
        toggleMenu(e) {
            $e.toggleMenu.call(this.player, e)
        }
    }
    var rt = "undefined" == typeof globalThis ? "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? {} : self : global : window : globalThis,
        dt = function(e, t) {
            return t = {
                exports: {}
            }, e(t, t.exports), t.exports
        }(function(e) {
            (function(t, n) {
                e.exports = n()
            })(rt, function() {
                function e(e, t) {
                    e = e.push ? e : [e];
                    var n, a, l, o, s = [],
                        u = e.length,
                        m = u;
                    for (n = function(e, n) {
                            n.length && s.push(e), m--, m || t(s)
                        }; u--;) {
                        if (a = e[u], l = d[a], l) {
                            n(a, l);
                            continue
                        }
                        o = c[a] = c[a] || [], o.push(n)
                    }
                }

                function t(e, t) {
                    if (e) {
                        var n = c[e];
                        if (d[e] = t, !!n)
                            for (; n.length;) n[0](e, t), n.splice(0, 1)
                    }
                }

                function n(e, t) {
                    e.call && (e = {
                        success: e
                    }), t.length ? (e.error || o)(t) : (e.success || o)(e)
                }

                function a(t, n, i, l) {
                    var s, r, d = document,
                        c = i.async,
                        u = (i.numRetries || 0) + 1,
                        m = i.before || o,
                        p = t.replace(/[\?|#].*$/, ""),
                        g = t.replace(/^(css|img)!/, "");
                    l = l || 0, /(^css!|\.css$)/.test(p) ? (r = d.createElement("link"), r.rel = "stylesheet", r.href = g, s = "hideFocus" in r, s && r.relList && (s = 0, r.rel = "preload", r.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(p) ? (r = d.createElement("img"), r.src = g) : (r = d.createElement("script"), r.src = t, r.async = void 0 === c || c), r.onload = r.onerror = r.onbeforeload = function(e) {
                        var o = e.type[0];
                        if (s) try {
                            r.sheet.cssText.length || (o = "e")
                        } catch (e) {
                            18 != e.code && (o = "e")
                        }
                        if ("e" == o) {
                            if (l += 1, l < u) return a(t, n, i, l);
                        } else if ("preload" == r.rel && "style" == r.as) return r.rel = "stylesheet";
                        n(t, o, e.defaultPrevented)
                    }, !1 !== m(t, r) && d.head.appendChild(r)
                }

                function i(e, t, n) {
                    e = e.push ? e : [e];
                    var l, o, s = e.length,
                        r = s,
                        d = [];
                    for (l = function(e, n, a) {
                            if ("e" == n && d.push(e), "b" == n)
                                if (a) d.push(e);
                                else return;
                            s--, s || t(d)
                        }, o = 0; o < r; o++) a(e[o], l, n)
                }

                function l(e, a, l) {
                    function o(a, l) {
                        i(e, function(e) {
                            n(d, e), a && n({
                                success: a,
                                error: l
                            }, e), t(r, e)
                        }, d)
                    }
                    var r, d;
                    if (a && a.trim && (r = a), d = (r ? l : a) || {}, r)
                        if (r in s) throw "LoadJS";
                        else s[r] = !0;
                    return d.returnPromise ? new Promise(o) : void o()
                }
                var o = function() {},
                    s = {},
                    d = {},
                    c = {};
                return l.ready = function(t, a) {
                    return e(t, function(e) {
                        n(a, e)
                    }), l
                }, l.done = function(e) {
                    t(e, [])
                }, l.reset = function() {
                    s = {}, d = {}, c = {}
                }, l.isDefined = function(e) {
                    return e in s
                }, l
            })
        });
    const ct = {
            setup() {
                const e = this;
                P(e.elements.wrapper, e.config.classNames.embed, !0), e.options.speed = e.config.speed.options, B.call(e), qe.object(window.Vimeo) ? ct.ready.call(e) : re(e.config.urls.vimeo.sdk).then(() => {
                    ct.ready.call(e)
                }).catch(t => {
                    e.debug.warn("Vimeo SDK (player.js) failed to load", t)
                })
            },
            ready() {
                const e = this,
                    t = e.config.vimeo,
                    {
                        premium: n,
                        referrerPolicy: a,
                        ...i
                    } = t;
                let l = e.media.getAttribute("src"),
                    o = "";
                qe.empty(l) ? (l = e.media.getAttribute(e.config.attributes.embed.id), o = e.media.getAttribute(e.config.attributes.embed.hash)) : o = ce(l);
                const s = o ? {
                    h: o
                } : {};
                n && Object.assign(i, {
                    controls: !1,
                    sidedock: !1
                });
                const d = le({
                        loop: e.config.loop.active,
                        autoplay: e.autoplay,
                        muted: e.muted,
                        gesture: "media",
                        playsinline: !this.config.fullscreen.iosNative,
                        ...s,
                        ...i
                    }),
                    c = de(l),
                    u = v("iframe"),
                    m = Q(e.config.urls.vimeo.iframe, c, d);
                if (u.setAttribute("src", m), u.setAttribute("allowfullscreen", ""), u.setAttribute("allow", "autoplay; fullscreen; picture-in-picture; encrypted-media; accelerometer; gyroscope"), qe.empty(a) || u.setAttribute("referrerPolicy", a), n || !t.customControls) u.setAttribute("data-poster", e.poster), e.media = A(u, e.media);
                else {
                    const t = v("div", {
                        class: e.config.classNames.embedContainer,
                        "data-poster": e.poster
                    });
                    t.appendChild(u), e.media = A(t, e.media)
                }
                t.customControls || te(Q(e.config.urls.vimeo.api, m)).then(t => {
                    qe.empty(t) || !t.thumbnail_url || ot.setPoster.call(e, t.thumbnail_url).catch(() => {})
                }), e.embed = new window.Vimeo.Player(u, {
                    autopause: e.config.autopause,
                    muted: e.muted
                }), e.media.paused = !0, e.media.currentTime = 0, e.supported.ui && e.embed.disableTextTrack(), e.media.play = () => (ue.call(e, !0), e.embed.play()), e.media.pause = () => (ue.call(e, !1), e.embed.pause()), e.media.stop = () => {
                    e.pause(), e.currentTime = 0
                };
                let {
                    currentTime: p
                } = e.media;
                Object.defineProperty(e.media, "currentTime", {
                    get() {
                        return p
                    },
                    set(t) {
                        const {
                            embed: n,
                            media: a,
                            paused: i,
                            volume: l
                        } = e, o = i && !n.hasPlayed;
                        a.seeking = !0, r.call(e, a, "seeking"), Promise.resolve(o && n.setVolume(0)).then(() => n.setCurrentTime(t)).then(() => o && n.pause()).then(() => o && n.setVolume(l)).catch(() => {})
                    }
                });
                let g = e.config.speed.selected;
                Object.defineProperty(e.media, "playbackRate", {
                    get() {
                        return g
                    },
                    set(t) {
                        e.embed.setPlaybackRate(t).then(() => {
                            g = t, r.call(e, e.media, "ratechange")
                        }).catch(() => {
                            e.options.speed = [1]
                        })
                    }
                });
                let {
                    volume: f
                } = e.config;
                Object.defineProperty(e.media, "volume", {
                    get() {
                        return f
                    },
                    set(t) {
                        e.embed.setVolume(t).then(() => {
                            f = t, r.call(e, e.media, "volumechange")
                        })
                    }
                });
                let {
                    muted: y
                } = e.config;
                Object.defineProperty(e.media, "muted", {
                    get() {
                        return y
                    },
                    set(t) {
                        const n = !!qe.boolean(t) && t;
                        e.embed.setVolume(n ? 0 : e.config.volume).then(() => {
                            y = n, r.call(e, e.media, "volumechange")
                        })
                    }
                });
                let {
                    loop: b
                } = e.config;
                Object.defineProperty(e.media, "loop", {
                    get() {
                        return b
                    },
                    set(t) {
                        const n = qe.boolean(t) ? t : e.config.loop.active;
                        e.embed.setLoop(n).then(() => {
                            b = n
                        })
                    }
                });
                let h;
                e.embed.getVideoUrl().then(t => {
                    h = t, $e.setDownloadUrl.call(e)
                }).catch(e => {
                    this.debug.warn(e)
                }), Object.defineProperty(e.media, "currentSrc", {
                    get() {
                        return h
                    }
                }), Object.defineProperty(e.media, "ended", {
                    get() {
                        return e.currentTime === e.duration
                    }
                }), Promise.all([e.embed.getVideoWidth(), e.embed.getVideoHeight()]).then(t => {
                    const [n, a] = t;
                    e.embed.ratio = K(n, a), B.call(this)
                }), e.embed.setAutopause(e.config.autopause).then(t => {
                    e.config.autopause = t
                }), e.embed.getVideoTitle().then(t => {
                    e.config.title = t, ot.setTitle.call(this)
                }), e.embed.getCurrentTime().then(t => {
                    p = t, r.call(e, e.media, "timeupdate")
                }), e.embed.getDuration().then(t => {
                    e.media.duration = t, r.call(e, e.media, "durationchange")
                }), e.embed.getTextTracks().then(t => {
                    e.media.textTracks = t, Je.setup.call(e)
                }), e.embed.on("cuechange", ({
                    cues: t = []
                }) => {
                    const n = t.map(e => Z(e.text));
                    Je.updateCues.call(e, n)
                }), e.embed.on("loaded", () => {
                    if (e.embed.getPaused().then(t => {
                            ue.call(e, !t), t || r.call(e, e.media, "playing")
                        }), qe.element(e.embed.element) && e.supported.ui) {
                        const t = e.embed.element;
                        t.setAttribute("tabindex", -1)
                    }
                }), e.embed.on("bufferstart", () => {
                    r.call(e, e.media, "waiting")
                }), e.embed.on("bufferend", () => {
                    r.call(e, e.media, "playing")
                }), e.embed.on("play", () => {
                    ue.call(e, !0), r.call(e, e.media, "playing")
                }), e.embed.on("pause", () => {
                    ue.call(e, !1)
                }), e.embed.on("timeupdate", t => {
                    e.media.seeking = !1, p = t.seconds, r.call(e, e.media, "timeupdate")
                }), e.embed.on("progress", t => {
                    e.media.buffered = t.percent, r.call(e, e.media, "progress"), 1 === parseInt(t.percent, 10) && r.call(e, e.media, "canplaythrough"), e.embed.getDuration().then(t => {
                        t !== e.media.duration && (e.media.duration = t, r.call(e, e.media, "durationchange"))
                    })
                }), e.embed.on("seeked", () => {
                    e.media.seeking = !1, r.call(e, e.media, "seeked")
                }), e.embed.on("ended", () => {
                    e.media.paused = !0, r.call(e, e.media, "ended")
                }), e.embed.on("error", t => {
                    e.media.error = t, r.call(e, e.media, "error")
                }), t.customControls && setTimeout(() => ot.build.call(e), 0)
            }
        },
        ut = {
            setup() {
                if (P(this.elements.wrapper, this.config.classNames.embed, !0), qe.object(window.YT) && qe.function(window.YT.Player)) ut.ready.call(this);
                else {
                    const e = window.onYouTubeIframeAPIReady;
                    window.onYouTubeIframeAPIReady = () => {
                        qe.function(e) && e(), ut.ready.call(this)
                    }, re(this.config.urls.youtube.sdk).catch(e => {
                        this.debug.warn("YouTube API failed to load", e)
                    })
                }
            },
            getTitle(e) {
                const t = Q(this.config.urls.youtube.api, e);
                te(t).then(e => {
                    if (qe.object(e)) {
                        const {
                            title: t,
                            height: n,
                            width: a
                        } = e;
                        this.config.title = t, ot.setTitle.call(this), this.embed.ratio = K(a, n)
                    }
                    B.call(this)
                }).catch(() => {
                    B.call(this)
                })
            },
            ready() {
                const e = this,
                    t = e.config.youtube,
                    n = e.media && e.media.getAttribute("id");
                if (!qe.empty(n) && n.startsWith("youtube-")) return;
                let a = e.media.getAttribute("src");
                qe.empty(a) && (a = e.media.getAttribute(this.config.attributes.embed.id));
                const i = me(a),
                    l = X(e.provider),
                    o = v("div", {
                        id: l,
                        "data-poster": t.customControls ? e.poster : void 0
                    });
                if (e.media = A(o, e.media), t.customControls) {
                    const t = e => `https://i.ytimg.com/vi/${i}/${e}default.jpg`;
                    se(t("maxres"), 121).catch(() => se(t("sd"), 121)).catch(() => se(t("hq"))).then(t => ot.setPoster.call(e, t.src)).then(t => {
                        t.includes("maxres") || (e.elements.poster.style.backgroundSize = "cover")
                    }).catch(() => {})
                }
                e.embed = new window.YT.Player(e.media, {
                    videoId: i,
                    host: ge(t),
                    playerVars: y({}, {
                        autoplay: e.config.autoplay ? 1 : 0,
                        hl: e.config.hl,
                        controls: e.supported.ui && t.customControls ? 0 : 1,
                        disablekb: 1,
                        playsinline: e.config.fullscreen.iosNative ? 0 : 1,
                        cc_load_policy: e.captions.active ? 1 : 0,
                        cc_lang_pref: e.config.captions.language,
                        widget_referrer: window ? window.location.href : null
                    }, t),
                    events: {
                        onError(t) {
                            if (!e.media.error) {
                                const n = t.data,
                                    a = {
                                        2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
                                        5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
                                        100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
                                        101: "The owner of the requested video does not allow it to be played in embedded players.",
                                        150: "The owner of the requested video does not allow it to be played in embedded players."
                                    }[n] || "An unknown error occured";
                                e.media.error = {
                                    code: n,
                                    message: a
                                }, r.call(e, e.media, "error")
                            }
                        },
                        onPlaybackRateChange(t) {
                            const n = t.target;
                            e.media.playbackRate = n.getPlaybackRate(), r.call(e, e.media, "ratechange")
                        },
                        onReady(n) {
                            if (qe.function(e.media.play)) return;
                            const a = n.target;
                            ut.getTitle.call(e, i), e.media.play = () => {
                                pe.call(e, !0), a.playVideo()
                            }, e.media.pause = () => {
                                pe.call(e, !1), a.pauseVideo()
                            }, e.media.stop = () => {
                                a.stopVideo()
                            }, e.media.duration = a.getDuration(), e.media.paused = !0, e.media.currentTime = 0, Object.defineProperty(e.media, "currentTime", {
                                get() {
                                    return +a.getCurrentTime()
                                },
                                set(t) {
                                    e.paused && !e.embed.hasPlayed && e.embed.mute(), e.media.seeking = !0, r.call(e, e.media, "seeking"), a.seekTo(t)
                                }
                            }), Object.defineProperty(e.media, "playbackRate", {
                                get() {
                                    return a.getPlaybackRate()
                                },
                                set(e) {
                                    a.setPlaybackRate(e)
                                }
                            });
                            let {
                                volume: l
                            } = e.config;
                            Object.defineProperty(e.media, "volume", {
                                get() {
                                    return l
                                },
                                set(t) {
                                    l = t, a.setVolume(100 * l), r.call(e, e.media, "volumechange")
                                }
                            });
                            let {
                                muted: o
                            } = e.config;
                            Object.defineProperty(e.media, "muted", {
                                get() {
                                    return o
                                },
                                set(t) {
                                    const n = qe.boolean(t) ? t : o;
                                    o = n, a[n ? "mute" : "unMute"](), a.setVolume(100 * l), r.call(e, e.media, "volumechange")
                                }
                            }), Object.defineProperty(e.media, "currentSrc", {
                                get() {
                                    return a.getVideoUrl()
                                }
                            }), Object.defineProperty(e.media, "ended", {
                                get() {
                                    return e.currentTime === e.duration
                                }
                            });
                            const s = a.getAvailablePlaybackRates();
                            e.options.speed = s.filter(t => e.config.speed.options.includes(t)), e.supported.ui && t.customControls && e.media.setAttribute("tabindex", -1), r.call(e, e.media, "timeupdate"), r.call(e, e.media, "durationchange"), clearInterval(e.timers.buffering), e.timers.buffering = setInterval(() => {
                                e.media.buffered = a.getVideoLoadedFraction(), (null === e.media.lastBuffered || e.media.lastBuffered < e.media.buffered) && r.call(e, e.media, "progress"), e.media.lastBuffered = e.media.buffered, 1 === e.media.buffered && (clearInterval(e.timers.buffering), r.call(e, e.media, "canplaythrough"))
                            }, 200), t.customControls && setTimeout(() => ot.build.call(e), 50)
                        },
                        onStateChange(n) {
                            const a = n.target;
                            clearInterval(e.timers.playing);
                            const i = e.media.seeking && [1, 2].includes(n.data);
                            switch (i && (e.media.seeking = !1, r.call(e, e.media, "seeked")), n.data) {
                                case -1:
                                    r.call(e, e.media, "timeupdate"), e.media.buffered = a.getVideoLoadedFraction(), r.call(e, e.media, "progress");
                                    break;
                                case 0:
                                    pe.call(e, !1), e.media.loop ? (a.stopVideo(), a.playVideo()) : r.call(e, e.media, "ended");
                                    break;
                                case 1:
                                    t.customControls && !e.config.autoplay && e.media.paused && !e.embed.hasPlayed ? e.media.pause() : (pe.call(e, !0), r.call(e, e.media, "playing"), e.timers.playing = setInterval(() => {
                                        r.call(e, e.media, "timeupdate")
                                    }, 50), e.media.duration !== a.getDuration() && (e.media.duration = a.getDuration(), r.call(e, e.media, "durationchange")));
                                    break;
                                case 2:
                                    e.muted || e.embed.unMute(), pe.call(e, !1);
                                    break;
                                case 3:
                                    r.call(e, e.media, "waiting");
                            }
                            r.call(e, e.elements.container, "statechange", !1, {
                                code: n.data
                            })
                        }
                    }
                })
            }
        },
        mt = {
            setup() {
                return this.media ? void(P(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), P(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && P(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = v("div", {
                    class: this.config.classNames.video
                }), b(this.media, this.elements.wrapper), this.elements.poster = v("div", {
                    class: this.config.classNames.poster
                }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? Oe.setup.call(this) : this.isYouTube ? ut.setup.call(this) : this.isVimeo && ct.setup.call(this)) : void this.debug.warn("No media element found!")
            }
        },
        pt = e => {
            e.manager && e.manager.destroy(), e.elements.displayContainer && e.elements.displayContainer.destroy(), e.elements.container.remove()
        };
    class gt {
        constructor(t) {
            e(this, "load", () => {
                this.enabled && (qe.object(window.google) && qe.object(window.google.ima) ? this.ready() : re(this.player.config.urls.googleIMA.sdk).then(() => {
                    this.ready()
                }).catch(() => {
                    this.trigger("error", new Error("Google IMA SDK failed to load"))
                }))
            }), e(this, "ready", () => {
                this.enabled || pt(this), this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then(() => {
                    this.clearSafetyTimer("onAdsManagerLoaded()")
                }), this.listeners(), this.setupIMA()
            }), e(this, "setupIMA", () => {
                this.elements.container = v("div", {
                    class: this.player.config.classNames.ads
                }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, e => this.onAdsManagerLoaded(e), !1), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, e => this.onAdError(e), !1), this.requestAds()
            }), e(this, "requestAds", () => {
                const {
                    container: e
                } = this.player.elements;
                try {
                    const t = new google.ima.AdsRequest;
                    t.adTagUrl = this.tagUrl, t.linearAdSlotWidth = e.offsetWidth, t.linearAdSlotHeight = e.offsetHeight, t.nonLinearAdSlotWidth = e.offsetWidth, t.nonLinearAdSlotHeight = e.offsetHeight, t.forceNonLinearFullSlot = !1, t.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(t)
                } catch (e) {
                    this.onAdError(e)
                }
            }), e(this, "pollCountdown", (e = !1) => {
                if (!e) return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text");
                this.countdownTimer = setInterval(() => {
                    const e = ae(Math.max(this.manager.getRemainingTime(), 0)),
                        t = `${Ke.get("advertisement",this.player.config)} - ${e}`;
                    this.elements.container.setAttribute("data-badge-text", t)
                }, 100)
            }), e(this, "onAdsManagerLoaded", e => {
                if (this.enabled) {
                    const t = new google.ima.AdsRenderingSettings;
                    t.restoreCustomPlaybackStateOnAdBreakComplete = !0, t.enablePreloading = !0, this.manager = e.getAdsManager(this.player, t), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, e => this.onAdError(e)), Object.keys(google.ima.AdEvent.Type).forEach(e => {
                        this.manager.addEventListener(google.ima.AdEvent.Type[e], t => this.onAdEvent(t))
                    }), this.trigger("loaded")
                }
            }), e(this, "addCuePoints", () => {
                qe.empty(this.cuePoints) || this.cuePoints.forEach(e => {
                    if (0 !== e && -1 !== e && e < this.player.duration) {
                        const t = this.player.elements.progress;
                        if (qe.element(t)) {
                            const n = 100 / this.player.duration * e,
                                a = v("span", {
                                    class: this.player.config.classNames.cues
                                });
                            a.style.left = `${n.toString()}%`, t.appendChild(a)
                        }
                    }
                })
            }), e(this, "onAdEvent", e => {
                const {
                    container: t
                } = this.player.elements, n = e.getAd(), a = e.getAdData(), i = e => {
                    r.call(this.player, this.player.media, `ads${e.replace(/_/g,"").toLowerCase()}`)
                };
                switch (i(e.type), e.type) {
                    case google.ima.AdEvent.Type.LOADED:
                        this.trigger("loaded"), this.pollCountdown(!0), n.isLinear() || (n.width = t.offsetWidth, n.height = t.offsetHeight);
                        break;
                    case google.ima.AdEvent.Type.STARTED:
                        this.manager.setVolume(this.player.volume);
                        break;
                    case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                        this.player.ended ? this.loadAds() : this.loader.contentComplete();
                        break;
                    case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
                        this.pauseContent();
                        break;
                    case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                        this.pollCountdown(), this.resumeContent();
                        break;
                    case google.ima.AdEvent.Type.LOG:
                        a.adError && this.player.debug.warn(`Non-fatal ad error: ${a.adError.getMessage()}`);
                }
            }), e(this, "onAdError", e => {
                this.cancel(), this.player.debug.warn("Ads error", e)
            }), e(this, "listeners", () => {
                const {
                    container: e
                } = this.player.elements;
                let t;
                this.player.on("canplay", () => {
                    this.addCuePoints()
                }), this.player.on("ended", () => {
                    this.loader.contentComplete()
                }), this.player.on("timeupdate", () => {
                    t = this.player.currentTime
                }), this.player.on("seeked", () => {
                    const e = this.player.currentTime;
                    qe.empty(this.cuePoints) || this.cuePoints.forEach((n, a) => {
                        t < n && n < e && (this.manager.discardAdBreak(), this.cuePoints.splice(a, 1))
                    })
                }), window.addEventListener("resize", () => {
                    this.manager && this.manager.resize(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL)
                })
            }), e(this, "play", () => {
                const {
                    container: e
                } = this.player.elements;
                this.managerPromise || this.resumeContent(), this.managerPromise.then(() => {
                    this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize();
                    try {
                        this.initialized || (this.manager.init(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL), this.manager.start()), this.initialized = !0
                    } catch (e) {
                        this.onAdError(e)
                    }
                }).catch(() => {})
            }), e(this, "resumeContent", () => {
                this.elements.container.style.zIndex = "", this.playing = !1, R(this.player.media.play())
            }), e(this, "pauseContent", () => {
                this.elements.container.style.zIndex = 3, this.playing = !0, this.player.media.pause()
            }), e(this, "cancel", () => {
                this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds()
            }), e(this, "loadAds", () => {
                this.managerPromise.then(() => {
                    this.manager && this.manager.destroy(), this.managerPromise = new Promise(e => {
                        this.on("loaded", e), this.player.debug.log(this.manager)
                    }), this.initialized = !1, this.requestAds()
                }).catch(() => {})
            }), e(this, "trigger", (e, ...t) => {
                const n = this.events[e];
                qe.array(n) && n.forEach(e => {
                    qe.function(e) && e.apply(this, t)
                })
            }), e(this, "on", (e, t) => (qe.array(this.events[e]) || (this.events[e] = []), this.events[e].push(t), this)), e(this, "startSafetyTimer", (e, t) => {
                this.player.debug.log(`Safety timer invoked from: ${t}`), this.safetyTimer = setTimeout(() => {
                    this.cancel(), this.clearSafetyTimer("startSafetyTimer()")
                }, e)
            }), e(this, "clearSafetyTimer", e => {
                qe.nullOrUndefined(this.safetyTimer) || (this.player.debug.log(`Safety timer cleared from: ${e}`), clearTimeout(this.safetyTimer), this.safetyTimer = null)
            }), this.player = t, this.config = t.config.ads, this.playing = !1, this.initialized = !1, this.elements = {
                container: null,
                displayContainer: null
            }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise((e, t) => {
                this.on("loaded", e), this.on("error", t)
            }), this.load()
        }
        get enabled() {
            const {
                config: e
            } = this;
            return this.player.isHTML5 && this.player.isVideo && e.enabled && (!qe.empty(e.publisherId) || qe.url(e.tagUrl))
        }
        get tagUrl() {
            const {
                config: e
            } = this;
            if (qe.url(e.tagUrl)) return e.tagUrl;
            const t = {
                AV_PUBLISHERID: "58c25bb0073ef448b1087ad6",
                AV_CHANNELID: "5a0458dc28a06145e4519d21",
                AV_URL: window.location.hostname,
                cb: Date.now(),
                AV_WIDTH: 640,
                AV_HEIGHT: 480,
                AV_CDIM2: e.publisherId
            };
            return `${"https://go.aniview.com/api/adserver6/vast/"}?${le(t)}`
        }
    }
    const ft = e => {
            const t = [],
                n = e.split(/\r\n\r\n|\n\n|\r\r/);
            return n.forEach(e => {
                const n = {},
                    a = e.split(/\r\n|\n|\r/);
                a.forEach(e => {
                    if (!qe.number(n.startTime)) {
                        const t = e.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);
                        t && (n.startTime = 60 * (60 * +(t[1] || 0)) + 60 * +t[2] + +t[3] + +`0.${t[4]}`, n.endTime = 60 * (60 * +(t[6] || 0)) + 60 * +t[7] + +t[8] + +`0.${t[9]}`)
                    } else if (!qe.empty(e.trim()) && qe.empty(n.text)) {
                        const t = e.trim().split("#xywh=");
                        [n.text] = t, t[1] && ([n.x, n.y, n.w, n.h] = t[1].split(","))
                    }
                }), n.text && t.push(n)
            }), t
        },
        yt = (e, t) => {
            const n = t.width / t.height,
                a = {};
            return e > n ? (a.width = t.width, a.height = 1 / e * t.width) : (a.height = t.height, a.width = e * t.height), a
        };
    class bt {
        constructor(t) {
            e(this, "load", () => {
                this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then(() => {
                    this.enabled && (this.render(), this.determineContainerAutoSizing(), this.loaded = !0)
                })
            }), e(this, "getThumbnails", () => new Promise(e => {
                const {
                    src: t
                } = this.player.config.previewThumbnails;
                if (qe.empty(t)) throw new Error("Missing previewThumbnails.src config attribute");
                const n = () => {
                    this.thumbnails.sort((e, t) => e.height - t.height), this.player.debug.log("Preview thumbnails", this.thumbnails), e()
                };
                if (qe.function(t)) t(e => {
                    this.thumbnails = e, n()
                });
                else {
                    const e = qe.string(t) ? [t] : t,
                        a = e.map(e => this.getThumbnail(e));
                    Promise.all(a).then(n)
                }
            })), e(this, "getThumbnail", e => new Promise(t => {
                te(e).then(n => {
                    const a = {
                        frames: ft(n),
                        height: null,
                        urlPrefix: ""
                    };
                    a.frames[0].text.startsWith("/") || a.frames[0].text.startsWith("http://") || a.frames[0].text.startsWith("https://") || (a.urlPrefix = e.substring(0, e.lastIndexOf("/") + 1));
                    const i = new Image;
                    i.onload = () => {
                        a.height = i.naturalHeight, a.width = i.naturalWidth, this.thumbnails.push(a), t()
                    }, i.src = a.urlPrefix + a.frames[0].text
                })
            })), e(this, "startMove", e => {
                if (this.loaded && qe.event(e) && ["touchmove", "mousemove"].includes(e.type) && this.player.media.duration) {
                    if ("touchmove" === e.type) this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
                    else {
                        var t, n;
                        const a = this.player.elements.progress.getBoundingClientRect(),
                            i = 100 / a.width * (e.pageX - a.left);
                        this.seekTime = this.player.media.duration * (i / 100), 0 > this.seekTime && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = e.pageX, this.elements.thumb.time.innerText = ae(this.seekTime);
                        const l = null === (t = this.player.config.markers) || void 0 === t || null === (n = t.points) || void 0 === n ? void 0 : n.find(({
                            time: e
                        }) => e === Math.round(this.seekTime));
                        l && this.elements.thumb.time.insertAdjacentHTML("afterbegin", `${l.label}<br>`)
                    }
                    this.showImageAtCurrentTime()
                }
            }), e(this, "endMove", () => {
                this.toggleThumbContainer(!1, !0)
            }), e(this, "startScrubbing", e => {
                (qe.nullOrUndefined(e.button) || !1 === e.button || 0 === e.button) && (this.mouseDown = !0, this.player.media.duration && (this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime()))
            }), e(this, "endScrubbing", () => {
                this.mouseDown = !1, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(!1) : n.call(this.player, this.player.media, "timeupdate", () => {
                    this.mouseDown || this.toggleScrubbingContainer(!1)
                })
            }), e(this, "listeners", () => {
                this.player.on("play", () => {
                    this.toggleThumbContainer(!1, !0)
                }), this.player.on("seeked", () => {
                    this.toggleThumbContainer(!1)
                }), this.player.on("timeupdate", () => {
                    this.lastTime = this.player.media.currentTime
                })
            }), e(this, "render", () => {
                this.elements.thumb.container = v("div", {
                    class: this.player.config.classNames.previewThumbnails.thumbContainer
                }), this.elements.thumb.imageContainer = v("div", {
                    class: this.player.config.classNames.previewThumbnails.imageContainer
                }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);
                const e = v("div", {
                    class: this.player.config.classNames.previewThumbnails.timeContainer
                });
                this.elements.thumb.time = v("span", {}, "00:00"), e.appendChild(this.elements.thumb.time), this.elements.thumb.imageContainer.appendChild(e), qe.element(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = v("div", {
                    class: this.player.config.classNames.previewThumbnails.scrubbingContainer
                }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container)
            }), e(this, "destroy", () => {
                this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove()
            }), e(this, "showImageAtCurrentTime", () => {
                this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();
                const e = this.thumbnails[0].frames.findIndex(e => this.seekTime >= e.startTime && this.seekTime <= e.endTime),
                    t = 0 <= e;
                let n = 0;
                this.mouseDown || this.toggleThumbContainer(t), t && (this.thumbnails.forEach((t, a) => {
                    this.loadedImages.includes(t.frames[e].text) && (n = a)
                }), e !== this.showingThumb && (this.showingThumb = e, this.loadImage(n)))
            }), e(this, "loadImage", (e = 0) => {
                const t = this.showingThumb,
                    n = this.thumbnails[e],
                    {
                        urlPrefix: a
                    } = n,
                    i = n.frames[t],
                    l = n.frames[t].text,
                    o = a + l;
                if (!this.currentImageElement || this.currentImageElement.dataset.filename !== l) {
                    this.loadingImage && this.usingSprites && (this.loadingImage.onload = null);
                    const n = new Image;
                    n.src = o, n.dataset.index = t, n.dataset.filename = l, this.showingThumbFilename = l, this.player.debug.log(`Loading image: ${o}`), n.onload = () => this.showImage(n, i, e, t, l, !0), this.loadingImage = n, this.removeOldImages(n)
                } else this.showImage(this.currentImageElement, i, e, t, l, !1), this.currentImageElement.dataset.index = t, this.removeOldImages(this.currentImageElement)
            }), e(this, "showImage", (e, t, n, a, i, l = !0) => {
                this.player.debug.log(`Showing thumb: ${i}. num: ${a}. qual: ${n}. newimg: ${l}`), this.setImageSizeAndOffset(e, t), l && (this.currentImageContainer.appendChild(e), this.currentImageElement = e, !this.loadedImages.includes(i) && this.loadedImages.push(i)), this.preloadNearby(a, !0).then(this.preloadNearby(a, !1)).then(this.getHigherQuality(n, e, t, i))
            }), e(this, "removeOldImages", e => {
                Array.from(this.currentImageContainer.children).forEach(t => {
                    if ("img" === t.tagName.toLowerCase()) {
                        const n = this.usingSprites ? 500 : 1e3;
                        if (t.dataset.index !== e.dataset.index && !t.dataset.deleting) {
                            t.dataset.deleting = !0;
                            const {
                                currentImageContainer: e
                            } = this;
                            setTimeout(() => {
                                e.removeChild(t), this.player.debug.log(`Removing thumb: ${t.dataset.filename}`)
                            }, n)
                        }
                    }
                })
            }), e(this, "preloadNearby", (e, t = !0) => new Promise(n => {
                setTimeout(() => {
                    const a = this.thumbnails[0].frames[e].text;
                    if (this.showingThumbFilename === a) {
                        let i = t ? this.thumbnails[0].frames.slice(e) : this.thumbnails[0].frames.slice(0, e).reverse();
                        let l = !1;
                        i.forEach(e => {
                            const t = e.text;
                            if (t !== a && !this.loadedImages.includes(t)) {
                                l = !0, this.player.debug.log(`Preloading thumb filename: ${t}`);
                                const {
                                    urlPrefix: e
                                } = this.thumbnails[0], a = new Image;
                                a.src = e + t, a.onload = () => {
                                    this.player.debug.log(`Preloaded thumb filename: ${t}`), this.loadedImages.includes(t) || this.loadedImages.push(t), n()
                                }
                            }
                        }), l || n()
                    }
                }, 300)
            })), e(this, "getHigherQuality", (e, t, n, a) => {
                if (e < this.thumbnails.length - 1) {
                    let i = t.naturalHeight;
                    this.usingSprites && (i = n.h), i < this.thumbContainerHeight && setTimeout(() => {
                        this.showingThumbFilename === a && (this.player.debug.log(`Showing higher quality thumb for: ${a}`), this.loadImage(e + 1))
                    }, 300)
                }
            }), e(this, "toggleThumbContainer", (e = !1, t = !1) => {
                const n = this.player.config.classNames.previewThumbnails.thumbContainerShown;
                this.elements.thumb.container.classList.toggle(n, e), !e && t && (this.showingThumb = null, this.showingThumbFilename = null)
            }), e(this, "toggleScrubbingContainer", (e = !1) => {
                const t = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
                this.elements.scrubbing.container.classList.toggle(t, e), e || (this.showingThumb = null, this.showingThumbFilename = null)
            }), e(this, "determineContainerAutoSizing", () => {
                (20 < this.elements.thumb.imageContainer.clientHeight || 20 < this.elements.thumb.imageContainer.clientWidth) && (this.sizeSpecifiedInCSS = !0)
            }), e(this, "setThumbContainerSizeAndPos", () => {
                const {
                    imageContainer: e
                } = this.elements.thumb;
                if (!this.sizeSpecifiedInCSS) {
                    const t = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
                    e.style.height = `${this.thumbContainerHeight}px`, e.style.width = `${t}px`
                } else if (20 < e.clientHeight && 20 > e.clientWidth) {
                    const t = Math.floor(e.clientHeight * this.thumbAspectRatio);
                    e.style.width = `${t}px`
                } else if (20 > e.clientHeight && 20 < e.clientWidth) {
                    const t = Math.floor(e.clientWidth / this.thumbAspectRatio);
                    e.style.height = `${t}px`
                }
                this.setThumbContainerPos()
            }), e(this, "setThumbContainerPos", () => {
                const e = this.player.elements.progress.getBoundingClientRect(),
                    t = this.player.elements.container.getBoundingClientRect(),
                    {
                        container: n
                    } = this.elements.thumb,
                    a = t.left - e.left + 10,
                    i = t.right - e.left - n.clientWidth - 10,
                    l = this.mousePosX - e.left - n.clientWidth / 2,
                    o = fe(l, a, i);
                n.style.left = `${o}px`, n.style.setProperty("--preview-arrow-offset", `${l-o}px`)
            }), e(this, "setScrubbingContainerSize", () => {
                const {
                    width: e,
                    height: t
                } = yt(this.thumbAspectRatio, {
                    width: this.player.media.clientWidth,
                    height: this.player.media.clientHeight
                });
                this.elements.scrubbing.container.style.width = `${e}px`, this.elements.scrubbing.container.style.height = `${t}px`
            }), e(this, "setImageSizeAndOffset", (e, t) => {
                if (this.usingSprites) {
                    const n = this.thumbContainerHeight / t.h;
                    e.style.height = `${e.naturalHeight*n}px`, e.style.width = `${e.naturalWidth*n}px`, e.style.left = `-${t.x*n}px`, e.style.top = `-${t.y*n}px`
                }
            }), this.player = t, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = {
                thumb: {},
                scrubbing: {}
            }, this.load()
        }
        get enabled() {
            return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled
        }
        get currentImageContainer() {
            return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer
        }
        get usingSprites() {
            return Object.keys(this.thumbnails[0].frames[0]).includes("w")
        }
        get thumbAspectRatio() {
            return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height
        }
        get thumbContainerHeight() {
            if (this.mouseDown) {
                const {
                    height: e
                } = yt(this.thumbAspectRatio, {
                    width: this.player.media.clientWidth,
                    height: this.player.media.clientHeight
                });
                return e
            }
            return this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4)
        }
        get currentImageElement() {
            return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement
        }
        set currentImageElement(e) {
            this.mouseDown ? this.currentScrubbingImageElement = e : this.currentThumbnailImageElement = e
        }
    }
    const ht = {
        insertElements(e, t) {
            qe.string(t) ? T(e, this.media, {
                src: t
            }) : qe.array(t) && t.forEach(t => {
                T(e, this.media, t)
            })
        },
        change(e) {
            return f(e, "sources.length") ? void(Oe.cancelRequests.call(this), this.destroy.call(this, () => {
                this.options.quality = [], w(this.media), this.media = null, qe.element(this.elements.container) && this.elements.container.removeAttribute("class");
                const {
                    sources: t,
                    type: n
                } = e, [{
                    provider: i = tt.html5,
                    src: a
                }] = t, l = "html5" === i ? n : "div", o = "html5" === i ? {} : {
                    src: a
                };
                Object.assign(this, {
                    provider: i,
                    type: n,
                    supported: Ve.check(n, i, this.config.playsinline),
                    media: v(l, o)
                }), this.elements.container.appendChild(this.media), qe.boolean(e.autoplay) && (this.config.autoplay = e.autoplay), this.isHTML5 && (this.config.crossorigin && this.media.setAttribute("crossorigin", ""), this.config.autoplay && this.media.setAttribute("autoplay", ""), !qe.empty(e.poster) && (this.poster = e.poster), this.config.loop.active && this.media.setAttribute("loop", ""), this.config.muted && this.media.setAttribute("muted", ""), this.config.playsinline && this.media.setAttribute("playsinline", "")), ot.addStyleHook.call(this), this.isHTML5 && ht.insertElements.call(this, "source", t), this.config.title = e.title, mt.setup.call(this), this.isHTML5 && Object.keys(e).includes("tracks") && ht.insertElements.call(this, "track", e.tracks), (this.isHTML5 || this.isEmbed && !this.supported.ui) && ot.build.call(this), this.isHTML5 && this.media.load(), qe.empty(e.previewThumbnails) || (Object.assign(this.config.previewThumbnails, e.previewThumbnails), this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), this.config.previewThumbnails.enabled && (this.previewThumbnails = new bt(this))), this.fullscreen.update()
            }, !0)) : void this.debug.warn("Invalid source format")
        }
    };
    class vt {
        constructor(a, i) {
            if (e(this, "play", () => qe.function(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then(() => this.ads.play()).catch(() => R(this.media.play())), this.media.play()) : null), e(this, "pause", () => this.playing && qe.function(this.media.pause) ? this.media.pause() : null), e(this, "togglePlay", e => {
                    const t = qe.boolean(e) ? e : !this.playing;
                    return t ? this.play() : this.pause()
                }), e(this, "stop", () => {
                    this.isHTML5 ? (this.pause(), this.restart()) : qe.function(this.media.stop) && this.media.stop()
                }), e(this, "restart", () => {
                    this.currentTime = 0
                }), e(this, "rewind", e => {
                    this.currentTime -= qe.number(e) ? e : this.config.seekTime
                }), e(this, "forward", e => {
                    this.currentTime += qe.number(e) ? e : this.config.seekTime
                }), e(this, "increaseVolume", e => {
                    const t = this.media.muted ? 0 : this.volume;
                    this.volume = t + (qe.number(e) ? e : 0)
                }), e(this, "decreaseVolume", e => {
                    this.increaseVolume(-e)
                }), e(this, "airplay", () => {
                    Ve.airplay && this.media.webkitShowPlaybackTargetPicker()
                }), e(this, "toggleControls", e => {
                    if (this.supported.ui && !this.isAudio) {
                        const t = x(this.elements.container, this.config.classNames.hideControls),
                            n = "undefined" == typeof e ? void 0 : !e,
                            a = P(this.elements.container, this.config.classNames.hideControls, n);
                        if (a && qe.array(this.config.controls) && this.config.controls.includes("settings") && !qe.empty(this.config.settings) && $e.toggleMenu.call(this, !1), a !== t) {
                            const e = a ? "controlshidden" : "controlsshown";
                            r.call(this, this.media, e)
                        }
                        return !a
                    }
                    return !1
                }), e(this, "on", (e, t) => {
                    q.call(this, this.elements.container, e, t)
                }), e(this, "once", (e, t) => {
                    n.call(this, this.elements.container, e, t)
                }), e(this, "off", (e, n) => {
                    t(this.elements.container, e, n)
                }), e(this, "destroy", (e, t = !1) => {
                    if (this.ready) {
                        const n = () => {
                            document.body.style.overflow = "", this.embed = null, t ? (Object.keys(this.elements).length && (w(this.elements.buttons.play), w(this.elements.captions), w(this.elements.controls), w(this.elements.wrapper), this.elements.buttons.play = null, this.elements.captions = null, this.elements.controls = null, this.elements.wrapper = null), qe.function(e) && e()) : (D.call(this), Oe.cancelRequests.call(this), A(this.elements.original, this.elements.container), r.call(this, this.elements.original, "destroyed", !0), qe.function(e) && e.call(this.elements.original), this.ready = !1, setTimeout(() => {
                                this.elements = null, this.media = null
                            }, 200))
                        };
                        this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (ot.toggleNativeControls.call(this, !0), n()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && qe.function(this.embed.destroy) && this.embed.destroy(), n()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(n), setTimeout(n, 200))
                    }
                }), e(this, "supports", e => Ve.mime.call(this, e)), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = Ve.touch, this.media = a, qe.string(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || qe.nodeList(this.media) || qe.array(this.media)) && (this.media = this.media[0]), this.config = y({}, Ze, vt.defaults, i || {}, (() => {
                    try {
                        return JSON.parse(this.media.getAttribute("data-plyr-config"))
                    } catch (e) {
                        return {}
                    }
                })()), this.elements = {
                    container: null,
                    fullscreen: null,
                    captions: null,
                    buttons: {},
                    display: {},
                    progress: {},
                    inputs: {},
                    settings: {
                        popup: null,
                        menu: null,
                        panels: {},
                        buttons: {}
                    }
                }, this.captions = {
                    active: null,
                    currentTrack: -1,
                    meta: new WeakMap
                }, this.fullscreen = {
                    active: !1
                }, this.options = {
                    speed: [],
                    quality: []
                }, this.debug = new it(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", Ve), qe.nullOrUndefined(this.media) || !qe.element(this.media)) return void this.debug.error("Setup failed: no suitable element passed");
            if (this.media.plyr) return void this.debug.warn("Target already setup");
            if (!this.config.enabled) return void this.debug.error("Setup failed: disabled by config");
            if (!Ve.check().api) return void this.debug.error("Setup failed: no support");
            const l = this.media.cloneNode(!0);
            l.autoplay = !1, this.elements.original = l;
            const o = this.media.tagName.toLowerCase();
            let s = null,
                d = null;
            switch (o) {
                case "div":
                    if (s = this.media.querySelector("iframe"), !qe.element(s)) this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);
                    else if (d = ie(s.getAttribute("src")), this.provider = oe(d.toString()), this.elements.container = this.media, this.media = s, this.elements.container.className = "", d.search.length) {
                        const e = ["1", "true"];
                        e.includes(d.searchParams.get("autoplay")) && (this.config.autoplay = !0), e.includes(d.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = e.includes(d.searchParams.get("playsinline")), this.config.youtube.hl = d.searchParams.get("hl")) : this.config.playsinline = !0
                    }
                    if (qe.empty(this.provider) || !Object.values(tt).includes(this.provider)) return void this.debug.error("Setup failed: Invalid provider");
                    this.type = nt.video;
                    break;
                case "video":
                case "audio":
                    this.type = o, this.provider = tt.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0);
                    break;
                default:
                    return void this.debug.error("Setup failed: unsupported type");
            }
            return this.supported = Ve.check(this.type, this.provider, this.config.playsinline), this.supported.api ? void(this.eventListeners = [], this.listeners = new st(this), this.storage = new Ye(this), this.media.plyr = this, !qe.element(this.elements.container) && (this.elements.container = v("div", {
                tabindex: 0
            }), b(this.media, this.elements.container)), ot.migrateStyles.call(this), ot.addStyleHook.call(this), mt.setup.call(this), this.config.debug && q.call(this, this.elements.container, this.config.events.join(" "), e => {
                this.debug.log(`event: ${e.type}`)
            }), this.fullscreen = new lt(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && ot.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new gt(this)), this.isHTML5 && this.config.autoplay && this.once("canplay", () => R(this.play())), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new bt(this))) : void this.debug.error("Setup failed: no support")
        }
        get isHTML5() {
            return this.provider === tt.html5
        }
        get isEmbed() {
            return this.isYouTube || this.isVimeo
        }
        get isYouTube() {
            return this.provider === tt.youtube
        }
        get isVimeo() {
            return this.provider === tt.vimeo
        }
        get isVideo() {
            return this.type === nt.video
        }
        get isAudio() {
            return this.type === nt.audio
        }
        get playing() {
            return !(!this.ready || this.paused || this.ended)
        }
        get paused() {
            return !!this.media.paused
        }
        get stopped() {
            return !!(this.paused && 0 === this.currentTime)
        }
        get ended() {
            return !!this.media.ended
        }
        set currentTime(e) {
            if (this.duration) {
                const t = qe.number(e) && 0 < e;
                this.media.currentTime = t ? Math.min(e, this.duration) : 0, this.debug.log(`Seeking to ${this.currentTime} seconds`)
            }
        }
        get currentTime() {
            return +this.media.currentTime
        }
        get buffered() {
            const {
                buffered: e
            } = this.media;
            return qe.number(e) ? e : e && e.length && 0 < this.duration ? e.end(0) / this.duration : 0
        }
        get seeking() {
            return !!this.media.seeking
        }
        get duration() {
            const e = parseFloat(this.config.duration),
                t = (this.media || {}).duration,
                n = qe.number(t) && t !== 1 / 0 ? t : 0;
            return e || n
        }
        set volume(e) {
            let t = e;
            const n = 0;
            qe.string(t) && (t = +t), qe.number(t) || (t = this.storage.get("volume")), qe.number(t) || ({
                volume: t
            } = this.config), 1 < t && (t = 1), t < n && (t = n), this.config.volume = t, this.media.volume = t, !qe.empty(e) && this.muted && 0 < t && (this.muted = !1)
        }
        get volume() {
            return +this.media.volume
        }
        set muted(e) {
            let t = e;
            qe.boolean(t) || (t = this.storage.get("muted")), qe.boolean(t) || (t = this.config.muted), this.config.muted = t, this.media.muted = t
        }
        get muted() {
            return !!this.media.muted
        }
        get hasAudio() {
            return !this.isHTML5 || !!this.isAudio || !!this.media.mozHasAudio || !!this.media.webkitAudioDecodedByteCount || !!(this.media.audioTracks && this.media.audioTracks.length)
        }
        set speed(e) {
            let t = null;
            qe.number(e) && (t = e), qe.number(t) || (t = this.storage.get("speed")), qe.number(t) || (t = this.config.speed.selected);
            const {
                minimumSpeed: n,
                maximumSpeed: a
            } = this;
            t = fe(t, n, a), this.config.speed.selected = t, setTimeout(() => {
                this.media && (this.media.playbackRate = t)
            }, 0)
        }
        get speed() {
            return +this.media.playbackRate
        }
        get minimumSpeed() {
            return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? .5 : .0625
        }
        get maximumSpeed() {
            return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16
        }
        set quality(e) {
            const t = this.config.quality,
                n = this.options.quality;
            if (!n.length) return;
            let a = [!qe.empty(e) && +e, this.storage.get("quality"), t.selected, t.default].find(qe.number),
                i = !0;
            if (!n.includes(a)) {
                const e = U(n, a);
                this.debug.warn(`Unsupported quality option: ${a}, using ${e} instead`), a = e, i = !1
            }
            t.selected = a, this.media.quality = a, i && this.storage.set({
                quality: a
            })
        }
        get quality() {
            return this.media.quality
        }
        set loop(e) {
            const t = qe.boolean(e) ? e : this.config.loop.active;
            this.config.loop.active = t, this.media.loop = t
        }
        get loop() {
            return !!this.media.loop
        }
        set source(e) {
            ht.change.call(this, e)
        }
        get source() {
            return this.media.currentSrc
        }
        get download() {
            const {
                download: e
            } = this.config.urls;
            return qe.url(e) ? e : this.source
        }
        set download(e) {
            qe.url(e) && (this.config.urls.download = e, $e.setDownloadUrl.call(this))
        }
        set poster(e) {
            return this.isVideo ? void ot.setPoster.call(this, e, !1).catch(() => {}) : void this.debug.warn("Poster can only be set for video")
        }
        get poster() {
            return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null
        }
        get ratio() {
            if (!this.isVideo) return null;
            const e = z(j.call(this));
            return qe.array(e) ? e.join(":") : e
        }
        set ratio(e) {
            return this.isVideo ? qe.string(e) && O(e) ? void(this.config.ratio = z(e), B.call(this)) : void this.debug.error(`Invalid aspect ratio specified (${e})`) : void this.debug.warn("Aspect ratio can only be set for video")
        }
        set autoplay(e) {
            this.config.autoplay = qe.boolean(e) ? e : this.config.autoplay
        }
        get autoplay() {
            return !!this.config.autoplay
        }
        toggleCaptions(e) {
            Je.toggle.call(this, e, !1)
        }
        set currentTrack(e) {
            Je.set.call(this, e, !1), Je.setup.call(this)
        }
        get currentTrack() {
            const {
                toggled: e,
                currentTrack: t
            } = this.captions;
            return e ? t : -1
        }
        set language(e) {
            Je.setLanguage.call(this, e, !1)
        }
        get language() {
            return (Je.getCurrentTrack.call(this) || {}).language
        }
        set pip(e) {
            if (Ve.pip) {
                const t = qe.boolean(e) ? e : !this.pip;
                qe.function(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(t ? et.active : et.inactive), qe.function(this.media.requestPictureInPicture) && (!this.pip && t ? this.media.requestPictureInPicture() : this.pip && !t && document.exitPictureInPicture())
            }
        }
        get pip() {
            return Ve.pip ? qe.empty(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === et.active : null
        }
        setPreviewThumbnails(e) {
            this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), Object.assign(this.config.previewThumbnails, e), this.config.previewThumbnails.enabled && (this.previewThumbnails = new bt(this))
        }
        static supported(e, t, n) {
            return Ve.check(e, t, n)
        }
        static loadSprite(e, t) {
            return ne(e, t)
        }
        static setup(e, n = {}) {
            let a = null;
            return qe.string(e) ? a = Array.from(document.querySelectorAll(e)) : qe.nodeList(e) ? a = Array.from(e) : qe.array(e) && (a = e.filter(qe.element)), qe.empty(a) ? null : a.map(e => new vt(e, n))
        }
    }
    return vt.defaults = function(e) {
        return JSON.parse(JSON.stringify(e))
    }(Ze), vt
});